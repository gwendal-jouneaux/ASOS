/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.adaptivesemantics.serializer;

import com.google.inject.Inject;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.AdaptiveSemantics;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.AdaptivesemanticsPackage;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Binding;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Conclusion;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Condition;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Import;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Input;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListRef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Output;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Premise;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.RefConfiguration;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Self;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SemanticDomainAccess;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolRef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.VoidList;
import fr.irisa.diverse.adaptivesemantics.services.AdaptSemGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AdaptSemSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AdaptSemGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AdaptivesemanticsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AdaptivesemanticsPackage.ADAPTIVE_SEMANTICS:
				sequence_AdaptiveSemantics(context, (AdaptiveSemantics) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.CONCLUSION:
				sequence_Conclusion(context, (Conclusion) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.DEF_CONFIGURATION:
				sequence_DefConfiguration(context, (DefConfiguration) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.LIST_DEF:
				sequence_ListDef(context, (ListDef) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.LIST_REF:
				sequence_ListRef(context, (ListRef) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.PREMISE:
				sequence_Premise(context, (Premise) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.REF_CONFIGURATION:
				sequence_RefConfiguration(context, (RefConfiguration) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SELF:
				sequence_Self(context, (Self) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SEMANTIC_DOMAIN_ACCESS:
				sequence_SemanticDomainAccess(context, (SemanticDomainAccess) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SYMBOL_DEF:
				sequence_SymbolDef(context, (SymbolDef) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SYMBOL_REF:
				sequence_SymbolRef(context, (SymbolRef) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.VOID_LIST:
				sequence_VoidList(context, (VoidList) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdaptiveSemantics returns AdaptiveSemantics
	 *
	 * Constraint:
	 *     (model=Model imports+=Import* rules+=Rule*)
	 */
	protected void sequence_AdaptiveSemantics(ISerializationContext context, AdaptiveSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (assignee=Assignee oclExpression=EString)
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.BINDING__ASSIGNEE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.BINDING__ASSIGNEE));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.BINDING__OCL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.BINDING__OCL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingAccess().getAssigneeAssigneeParserRuleCall_0_0(), semanticObject.getAssignee());
		feeder.accept(grammarAccess.getBindingAccess().getOclExpressionEStringParserRuleCall_2_0(), semanticObject.getOclExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Conclusion returns Conclusion
	 *
	 * Constraint:
	 *     (from=DefConfiguration termination?='termination'? to=SingleTermRef)
	 */
	protected void sequence_Conclusion(ISerializationContext context, Conclusion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     oclPredicate=EString
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.CONDITION__OCL_PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.CONDITION__OCL_PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getOclPredicateEStringParserRuleCall_1_0(), semanticObject.getOclPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermDef returns DefConfiguration
	 *     SingleTermDef returns DefConfiguration
	 *     DefConfiguration returns DefConfiguration
	 *
	 * Constraint:
	 *     (concept=[EClass|FQN] (childs+=TermDef childs+=TermDef*)?)
	 */
	protected void sequence_DefConfiguration(ISerializationContext context, DefConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (importURI=EString name=ID)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.IMPORT__IMPORT_URI));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURIEStringParserRuleCall_1_0(), semanticObject.getImportURI());
		feeder.accept(grammarAccess.getImportAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Input returns Input
	 *
	 * Constraint:
	 *     (assignee=Assignee operation=[EOperation|OperationFQN])
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.INPUT__ASSIGNEE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.INPUT__ASSIGNEE));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.INPUT__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.INPUT__OPERATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputAccess().getAssigneeAssigneeParserRuleCall_0_0(), semanticObject.getAssignee());
		feeder.accept(grammarAccess.getInputAccess().getOperationEOperationOperationFQNParserRuleCall_2_0_1(), semanticObject.eGet(AdaptivesemanticsPackage.Literals.INPUT__OPERATION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermDef returns ListDef
	 *     ListDef returns ListDef
	 *
	 * Constraint:
	 *     (head=SingleTermDef tail=SymbolDef)
	 */
	protected void sequence_ListDef(ISerializationContext context, ListDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.LIST_DEF__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.LIST_DEF__HEAD));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.LIST_DEF__TAIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.LIST_DEF__TAIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListDefAccess().getHeadSingleTermDefParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getListDefAccess().getTailSymbolDefParserRuleCall_3_0(), semanticObject.getTail());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermRef returns ListRef
	 *     ListRef returns ListRef
	 *
	 * Constraint:
	 *     (head=SymbolRef tail=SymbolRef)
	 */
	protected void sequence_ListRef(ISerializationContext context, ListRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.LIST_REF__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.LIST_REF__HEAD));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.LIST_REF__TAIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.LIST_REF__TAIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListRefAccess().getHeadSymbolRefParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getListRefAccess().getTailSymbolRefParserRuleCall_3_0(), semanticObject.getTail());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (importURI=EString semanticdomain=[EPackage|FQN])
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.MODEL__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.MODEL__IMPORT_URI));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.MODEL__SEMANTICDOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.MODEL__SEMANTICDOMAIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getImportURIEStringParserRuleCall_1_0(), semanticObject.getImportURI());
		feeder.accept(grammarAccess.getModelAccess().getSemanticdomainEPackageFQNParserRuleCall_3_0_1(), semanticObject.eGet(AdaptivesemanticsPackage.Literals.MODEL__SEMANTICDOMAIN, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (operation=[EOperation|OperationFQN] (args+=TermRef args+=TermRef*)?)
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Premise returns Premise
	 *
	 * Constraint:
	 *     (from=SymbolRef termination?='termination'? to=SingleTermDef)
	 */
	protected void sequence_Premise(ISerializationContext context, Premise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermRef returns RefConfiguration
	 *     SingleTermRef returns RefConfiguration
	 *     RefConfiguration returns RefConfiguration
	 *
	 * Constraint:
	 *     (concept=[EClass|FQN] (childs+=TermRef childs+=TermRef*)?)
	 */
	protected void sequence_RefConfiguration(ISerializationContext context, RefConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         conclusion=Conclusion 
	 *         conditions+=Condition* 
	 *         premises+=Premise* 
	 *         bindings+=Binding* 
	 *         (inputs+=Input | outputs+=Output)*
	 *     )
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TerminalAccessExpression returns Self
	 *     Self returns Self
	 *
	 * Constraint:
	 *     {Self}
	 */
	protected void sequence_Self(ISerializationContext context, Self semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns SemanticDomainAccess
	 *     SemanticDomainAccess returns SemanticDomainAccess
	 *     SemanticDomainAccess.SemanticDomainAccess_3_0 returns SemanticDomainAccess
	 *     TermRef returns SemanticDomainAccess
	 *     SingleTermRef returns SemanticDomainAccess
	 *
	 * Constraint:
	 *     ((reciever=TerminalAccessExpression field=ID) | (reciever=SemanticDomainAccess_SemanticDomainAccess_3_0 field=ID))
	 */
	protected void sequence_SemanticDomainAccess(ISerializationContext context, SemanticDomainAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns SymbolDef
	 *     TermDef returns SymbolDef
	 *     SingleTermDef returns SymbolDef
	 *     SymbolDef returns SymbolDef
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SymbolDef(ISerializationContext context, SymbolDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.SYMBOL_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.SYMBOL_DEF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TerminalAccessExpression returns SymbolRef
	 *     TermRef returns SymbolRef
	 *     SingleTermRef returns SymbolRef
	 *     SymbolRef returns SymbolRef
	 *
	 * Constraint:
	 *     def=[SymbolDef|ID]
	 */
	protected void sequence_SymbolRef(ISerializationContext context, SymbolRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.SYMBOL_REF__DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.SYMBOL_REF__DEF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolRefAccess().getDefSymbolDefIDTerminalRuleCall_1_0_1(), semanticObject.eGet(AdaptivesemanticsPackage.Literals.SYMBOL_REF__DEF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermDef returns VoidList
	 *     TermRef returns VoidList
	 *     VoidList returns VoidList
	 *
	 * Constraint:
	 *     {VoidList}
	 */
	protected void sequence_VoidList(ISerializationContext context, VoidList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

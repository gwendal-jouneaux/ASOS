/**
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.adaptivesemantics.generator;

import com.google.common.collect.Iterators;
import fr.irisa.diverse.adaptivesemantics.generator.visitors.RuleCompiler;
import fr.irisa.diverse.adaptivesemantics.generator.visitors.SymbolPath;
import fr.irisa.diverse.adaptivesemantics.generator.visitors.SymbolResolver;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Premise;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SingleTermDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;

@SuppressWarnings("all")
public class AdaptSemGenerator extends AbstractGenerator {
  private Map<EClass, List<Rule>> conceptRules = CollectionLiterals.<EClass, List<Rule>>newHashMap();
  
  private Map<EClass, List<Rule>> allRulesForConcept = CollectionLiterals.<EClass, List<Rule>>newHashMap();
  
  private Map<Rule, Map<SymbolDef, SymbolPath>> symbolTable = CollectionLiterals.<Rule, Map<SymbolDef, SymbolPath>>newHashMap();
  
  private static EPackage semanticdomain;
  
  private static String modelName;
  
  /**
   * Entrypoint of the generator
   * 
   * @param resource : result of the parser
   * @param fsa : access to the filesystem to generate files
   * @param context : unused
   */
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    Model _head = IteratorExtensions.<Model>head(Iterators.<Model>filter(resource.getAllContents(), Model.class));
    final Model metamodel = ((Model) _head);
    AdaptSemGenerator.semanticdomain = metamodel.getSemanticdomain();
    AdaptSemGenerator.modelName = NamingUtils.nameOf(metamodel);
    final List<Rule> rules = IteratorExtensions.<Rule>toList(Iterators.<Rule>filter(resource.getAllContents(), Rule.class));
    final Function1<Rule, EClass> _function = (Rule it) -> {
      return it.getConclusion().getFrom().getConcept();
    };
    this.conceptRules = IterableExtensions.<EClass, Rule>groupBy(rules, _function);
    final String interface_ = this.compileInterface(rules);
    fsa.generateFile(NamingUtils.interfacePathFor(AdaptSemGenerator.modelName, AdaptSemGenerator.modelName), interface_);
    this.groupRulesByConcept(this.conceptRules);
    this.createSymbolTableForRules();
    final Set<EClass> concepts = this.allRulesForConcept.keySet();
    for (final EClass concept : concepts) {
      {
        final String conceptName = concept.getName();
        final String operation = this.compileOperationFor(concept);
        fsa.generateFile(NamingUtils.operationPathFor(AdaptSemGenerator.modelName, conceptName), operation);
      }
    }
  }
  
  /**
   * Associate a concept to the list of rules that can be applied to it
   * 
   * @param rulesByConcept : map from concept (used as input in rules) to the list of rules defined for this exact concept
   */
  public void groupRulesByConcept(final Map<EClass, List<Rule>> rulesByConcept) {
    final Function1<EClass, Boolean> _function = (EClass c) -> {
      return Boolean.valueOf((!(c.isInterface() || c.isAbstract())));
    };
    final Iterable<EClass> concreteClasses = IterableExtensions.<EClass>filter(rulesByConcept.keySet(), _function);
    for (final EClass concept : concreteClasses) {
      {
        final List<Rule> rules = RuleUtils.getRulesFor(concept, rulesByConcept);
        final Comparator<Rule> _function_1 = (Rule r1, Rule r2) -> {
          return RuleUtils.compareRules(r1, r2);
        };
        rules.sort(_function_1);
        this.allRulesForConcept.put(concept, rules);
      }
    }
  }
  
  /**
   * Resolve symbols defined in rules to EMF model queries
   */
  public void createSymbolTableForRules() {
    final Set<EClass> concepts = this.allRulesForConcept.keySet();
    for (final EClass concept : concepts) {
      {
        final List<Rule> rules = this.allRulesForConcept.get(concept);
        for (final Rule rule : rules) {
          {
            final SymbolResolver resolver = new SymbolResolver();
            resolver.resolveFor(rule);
            final Map<SymbolDef, SymbolPath> ruleSymbols = resolver.getSymbolTable();
            this.symbolTable.put(rule, ruleSymbols);
          }
        }
      }
    }
  }
  
  /**
   * Generate the operation class for SEALS from the semantic rules for a given concept
   * 
   * @param concept : EClass representing the concept to generate the semantic for
   */
  public String compileOperationFor(final EClass concept) {
    String out = "";
    final List<Rule> rules = this.allRulesForConcept.get(concept);
    String computedTerms = "";
    final EList<EStructuralFeature> features = concept.getEAllStructuralFeatures();
    for (final EStructuralFeature feature : features) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append(computedTerms);
      _builder.newLineIfNotEmpty();
      _builder.append("Object ");
      String _computedNameFor = NamingUtils.computedNameFor(feature.getName());
      _builder.append(_computedNameFor);
      _builder.append(" = null;");
      _builder.newLineIfNotEmpty();
      {
        int _upperBound = feature.getUpperBound();
        boolean _notEquals = (_upperBound != 1);
        if (_notEquals) {
          _builder.append("int ");
          String _indexNameFor = NamingUtils.indexNameFor(feature.getName());
          _builder.append(_indexNameFor);
          _builder.append(" = 0;");
          _builder.newLineIfNotEmpty();
        }
      }
      computedTerms = _builder.toString();
    }
    for (int i = 0; (i < rules.size()); i++) {
      {
        final Rule first = rules.get(i);
        String _out = out;
        String _compileRule = this.compileRule(first);
        out = (_out + _compileRule);
      }
    }
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package ");
    _builder_1.append(AdaptSemGenerator.modelName);
    _builder_1.append(".operations;");
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    _builder_1.append("import java.util.List;");
    _builder_1.newLine();
    _builder_1.append("import org.eclipse.emf.ecore.EObject;");
    _builder_1.newLine();
    _builder_1.append("import org.eclipse.emf.ecore.util.EcoreUtil;");
    _builder_1.newLine();
    _builder_1.append("import fr.gjouneau.savm.framework.lang.semantics.AdaptiveOperation;");
    _builder_1.newLine();
    _builder_1.append("import fr.gjouneau.savm.framework.lang.semantics.Node;");
    _builder_1.newLine();
    _builder_1.append("import fr.gjouneau.savm.framework.lang.semantics.Operationalize;");
    _builder_1.newLine();
    _builder_1.append("import fr.gjouneau.savm.framework.lang.semantics.SelfAdaptiveVisitor;");
    _builder_1.newLine();
    _builder_1.append("import ");
    _builder_1.append(AdaptSemGenerator.modelName);
    _builder_1.append(".ASOS.Termination;");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("import ");
    _builder_1.append(AdaptSemGenerator.modelName);
    _builder_1.append(".*;");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("import ");
    _builder_1.append(AdaptSemGenerator.modelName);
    _builder_1.append(".");
    String _firstUpper = StringExtensions.toFirstUpper(AdaptSemGenerator.modelName);
    _builder_1.append(_firstUpper);
    _builder_1.append("Factory;");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("import ");
    _builder_1.append(AdaptSemGenerator.modelName);
    _builder_1.append(".interfaces.");
    String _interfaceNameFor = NamingUtils.interfaceNameFor(AdaptSemGenerator.modelName);
    _builder_1.append(_interfaceNameFor);
    _builder_1.append(";");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("import ");
    _builder_1.append(AdaptSemGenerator.modelName);
    _builder_1.append(".");
    String _name = AdaptSemGenerator.semanticdomain.getName();
    _builder_1.append(_name);
    _builder_1.append(".*;");
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    _builder_1.append("@Operationalize(node = ");
    String _name_1 = concept.getName();
    _builder_1.append(_name_1);
    _builder_1.append(".class, visitor = \"");
    _builder_1.append(AdaptSemGenerator.modelName);
    _builder_1.append(".visitors.");
    _builder_1.append(AdaptSemGenerator.modelName);
    _builder_1.append("Visitor\")");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("public class ");
    String _name_2 = concept.getName();
    _builder_1.append(_name_2);
    _builder_1.append("Op extends AdaptiveOperation<");
    String _name_3 = concept.getName();
    _builder_1.append(_name_3);
    _builder_1.append(", ");
    String _interfaceNameFor_1 = NamingUtils.interfaceNameFor(AdaptSemGenerator.modelName);
    _builder_1.append(_interfaceNameFor_1);
    _builder_1.append(">{");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@Override");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("public Object execute(SelfAdaptiveVisitor vis, ");
    String _name_4 = concept.getName();
    _builder_1.append(_name_4, "\t");
    _builder_1.append(" node, Object execCtx, ");
    String _interfaceNameFor_2 = NamingUtils.interfaceNameFor(AdaptSemGenerator.modelName);
    _builder_1.append(_interfaceNameFor_2, "\t");
    _builder_1.append(" config) {");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("\t\t");
    _builder_1.append("Object result = null;");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append(computedTerms, "\t\t");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("\t\t");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("while(true){");
    _builder_1.newLine();
    _builder_1.append("\t\t\t");
    _builder_1.append("Object termination = null;");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.newLine();
    _builder_1.append("\t\t\t");
    _builder_1.append(out, "\t\t\t");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("\t\t");
    _builder_1.newLine();
    _builder_1.append("\t\t\t");
    _builder_1.append("return termination;");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    return _builder_1.toString();
  }
  
  /**
   * Generate code corresponding to one rule
   * 
   * @param r : the rule to compile to java code
   */
  public String compileRule(final Rule r) {
    final Map<SymbolDef, SymbolPath> ruleTable = this.symbolTable.get(r);
    final RuleCompiler ruleCompiler = new RuleCompiler(ruleTable, AdaptSemGenerator.semanticdomain);
    return ruleCompiler.compile(r);
  }
  
  /**
   * @TODO
   * Generate code corresponding to a set of alternatives (rules) needing premises evaluation to select
   * 
   * @param rules : the rules seen as possible alternatives
   */
  public String compileRule(final List<Rule> rules) {
    String out = "";
    return out;
  }
  
  /**
   * GENERATE ADAPTATION INTERFACE
   */
  public String compileInterface(final List<Rule> rules) {
    String out = "";
    for (final Rule rule : rules) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("private AdaptationRule before_");
      String _name = rule.getName();
      _builder.append(_name);
      _builder.append(";");
      _builder.newLineIfNotEmpty();
      _builder.append("private AdaptationRule specialize_");
      String _name_1 = rule.getName();
      _builder.append(_name_1);
      _builder.append(";");
      _builder.newLineIfNotEmpty();
      _builder.append("private AdaptationRule after_");
      String _name_2 = rule.getName();
      _builder.append(_name_2);
      _builder.append(";");
      _builder.newLineIfNotEmpty();
      _builder.append(out);
      _builder.newLineIfNotEmpty();
      _builder.append("public void add_before_");
      String _name_3 = rule.getName();
      _builder.append(_name_3);
      _builder.append("(AdaptationRule adapt){");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      _builder.append("adapt.chain(before_");
      String _name_4 = rule.getName();
      _builder.append(_name_4, "\t");
      _builder.append(");");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      _builder.append("before_");
      String _name_5 = rule.getName();
      _builder.append(_name_5, "\t");
      _builder.append(" = adapt;");
      _builder.newLineIfNotEmpty();
      _builder.append("}");
      _builder.newLine();
      _builder.append("public void add_specialize_");
      String _name_6 = rule.getName();
      _builder.append(_name_6);
      _builder.append("(AdaptationRule adapt){");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      _builder.append("adapt.chain(specialize_");
      String _name_7 = rule.getName();
      _builder.append(_name_7, "\t");
      _builder.append(");");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      _builder.append("specialize_");
      String _name_8 = rule.getName();
      _builder.append(_name_8, "\t");
      _builder.append(" = adapt;");
      _builder.newLineIfNotEmpty();
      _builder.append("}");
      _builder.newLine();
      _builder.append("public void add_after_");
      String _name_9 = rule.getName();
      _builder.append(_name_9);
      _builder.append("(AdaptationRule adapt){");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      _builder.append("adapt.chain(after_");
      String _name_10 = rule.getName();
      _builder.append(_name_10, "\t");
      _builder.append(");");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      _builder.append("after_");
      String _name_11 = rule.getName();
      _builder.append(_name_11, "\t");
      _builder.append(" = adapt;");
      _builder.newLineIfNotEmpty();
      _builder.append("}");
      _builder.newLine();
      _builder.append("public AdaptationRule before_");
      String _name_12 = rule.getName();
      _builder.append(_name_12);
      _builder.append("(){return before_");
      String _name_13 = rule.getName();
      _builder.append(_name_13);
      _builder.append(";}");
      _builder.newLineIfNotEmpty();
      _builder.append("public AdaptationRule specialize_");
      String _name_14 = rule.getName();
      _builder.append(_name_14);
      _builder.append("(){return specialize_");
      String _name_15 = rule.getName();
      _builder.append(_name_15);
      _builder.append(";}");
      _builder.newLineIfNotEmpty();
      _builder.append("public AdaptationRule after_");
      String _name_16 = rule.getName();
      _builder.append(_name_16);
      _builder.append("(){return after_");
      String _name_17 = rule.getName();
      _builder.append(_name_17);
      _builder.append(";}");
      _builder.newLineIfNotEmpty();
      out = _builder.toString();
    }
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package ");
    _builder_1.append(AdaptSemGenerator.modelName);
    _builder_1.append(".interfaces;");
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    _builder_1.append("import fr.gjouneau.savm.framework.lang.semantics.SemanticsAdaptationInterface;");
    _builder_1.newLine();
    _builder_1.append("import ");
    _builder_1.append(AdaptSemGenerator.modelName);
    _builder_1.append(".ASOS.AdaptationRule;");
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    _builder_1.append("public class ");
    String _interfaceNameFor = NamingUtils.interfaceNameFor(AdaptSemGenerator.modelName);
    _builder_1.append(_interfaceNameFor);
    _builder_1.append(" implements SemanticsAdaptationInterface {");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("\t");
    _builder_1.append(out, "\t");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("}");
    _builder_1.newLine();
    return _builder_1.toString();
  }
  
  public void doGenerateOld(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Function1<Rule, EClass> _function = (Rule it) -> {
      return it.getConclusion().getFrom().getConcept();
    };
    final Map<EClass, List<Rule>> rulesByConcept = IteratorExtensions.<EClass, Rule>groupBy(Iterators.<Rule>filter(resource.getAllContents(), Rule.class), _function);
    AdaptSemGenerator.semanticdomain = IteratorExtensions.<Model>head(Iterators.<Model>filter(resource.getAllContents(), Model.class)).getSemanticdomain();
    final Function1<EClass, Boolean> _function_1 = (EClass c) -> {
      boolean _isAbstract = c.isAbstract();
      return Boolean.valueOf((!_isAbstract));
    };
    final Iterable<EClass> concreteClasses = IterableExtensions.<EClass>filter(rulesByConcept.keySet(), _function_1);
    for (final EClass concept : concreteClasses) {
      {
        final String conceptName = concept.getName();
        final List<Rule> rules = RuleUtils.getRulesFor(concept, rulesByConcept);
        final Comparator<Rule> _function_2 = (Rule r1, Rule r2) -> {
          return RuleUtils.compareRules(r1, r2);
        };
        rules.sort(_function_2);
        final Function1<Rule, String> _function_3 = (Rule it) -> {
          return it.getName();
        };
        String content = IterableExtensions.join(ListExtensions.<Rule, String>map(rules, _function_3), ", ");
        String _content = content;
        final Function1<EStructuralFeature, String> _function_4 = (EStructuralFeature it) -> {
          return it.getName();
        };
        String _join = IterableExtensions.join(ListExtensions.<EStructuralFeature, String>map(concept.getEAllStructuralFeatures(), _function_4), "\n");
        String _plus = ("\n\n" + _join);
        String _plus_1 = (_plus + "\n\n");
        content = (_content + _plus_1);
        for (final Rule rule : rules) {
          {
            final Map<SymbolDef, String> ruleSymbols = NamingUtils.getPathForSymbols(rule.getConclusion().getFrom());
            EList<Premise> _premises = rule.getPremises();
            for (final Premise premise : _premises) {
              SingleTermDef _to = premise.getTo();
              if ((_to instanceof SymbolDef)) {
                SingleTermDef _to_1 = premise.getTo();
                String _name = premise.getFrom().getDef().getName();
                String _plus_2 = ("computed_" + _name);
                ruleSymbols.put(((SymbolDef) _to_1), _plus_2);
              } else {
                SingleTermDef _to_2 = premise.getTo();
                if ((_to_2 instanceof DefConfiguration)) {
                  SingleTermDef _to_3 = premise.getTo();
                  ruleSymbols.putAll(NamingUtils.getPathForSymbols(((DefConfiguration) _to_3)));
                }
              }
            }
            String _content_1 = content;
            String _name_1 = rule.getName();
            String _plus_3 = (_name_1 + " :\n");
            content = (_content_1 + _plus_3);
            Set<SymbolDef> _keySet = ruleSymbols.keySet();
            for (final SymbolDef symbol : _keySet) {
              String _content_2 = content;
              String _name_2 = symbol.getName();
              String _plus_4 = (_name_2 + " : ");
              String _get = ruleSymbols.get(symbol);
              String _plus_5 = (_plus_4 + _get);
              String _plus_6 = (_plus_5 + "\n");
              content = (_content_2 + _plus_6);
            }
            String _content_3 = content;
            content = (_content_3 + "\n\n");
          }
        }
        for (int i = 0; (i < rules.size());) {
          {
            final Rule first = rules.get(i);
            String _content_1 = content;
            String _name = first.getName();
            String _plus_2 = (_name + ", ");
            content = (_content_1 + _plus_2);
            final ArrayList<Object> group = new ArrayList<Object>();
            int j = (i + 1);
            boolean end = false;
            while (((j < rules.size()) && (!end))) {
              {
                final DefConfiguration configI = first.getConclusion().getFrom();
                final DefConfiguration configJ = rules.get(j).getConclusion().getFrom();
                boolean _equals = EcoreUtil2.equals(configI, configJ);
                if (_equals) {
                  String _content_2 = content;
                  String _name_1 = rules.get(j).getName();
                  String _plus_3 = (_name_1 + ", ");
                  content = (_content_2 + _plus_3);
                } else {
                  end = true;
                  j--;
                }
                j++;
              }
            }
            String _content_2 = content;
            content = (_content_2 + "\n");
            i = j;
          }
        }
        Model _head = IteratorExtensions.<Model>head(Iterators.<Model>filter(resource.getAllContents(), Model.class));
        final Model m = ((Model) _head);
        String _importURI = m.getImportURI();
        int _lastIndexOf = m.getImportURI().lastIndexOf("/");
        int _plus_2 = (_lastIndexOf + 1);
        final String filename = _importURI.substring(_plus_2, m.getImportURI().lastIndexOf("."));
        fsa.generateFile((((filename + "/operations/") + conceptName) + "_test.txt"), content);
      }
    }
  }
  
  public static EPackage getSemanticDomain() {
    return AdaptSemGenerator.semanticdomain;
  }
  
  public static String getModelName() {
    return AdaptSemGenerator.modelName;
  }
}

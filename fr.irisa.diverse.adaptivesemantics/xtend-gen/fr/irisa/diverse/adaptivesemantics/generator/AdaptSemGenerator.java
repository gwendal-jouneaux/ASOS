/**
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.adaptivesemantics.generator;

import com.google.common.collect.Iterators;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Condition;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Premise;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SingleTermDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolRef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.TermDef;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;

@SuppressWarnings("all")
public class AdaptSemGenerator extends AbstractGenerator {
  private Map<EClass, List<Rule>> rulesForConcept = CollectionLiterals.<EClass, List<Rule>>newHashMap();
  
  private Map<Rule, Map<SymbolDef, String>> symbolTable = CollectionLiterals.<Rule, Map<SymbolDef, String>>newHashMap();
  
  private static EPackage semanticdomain;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    AdaptSemGenerator.semanticdomain = IteratorExtensions.<Model>head(Iterators.<Model>filter(resource.getAllContents(), Model.class)).getSemanticdomain();
    this.groupRulesByConcept(resource);
    this.createSymbolTableForRules();
    final Set<EClass> concepts = this.rulesForConcept.keySet();
    for (final EClass concept : concepts) {
      {
        final String conceptName = concept.getName();
        final String content = this.compileOperationFor(concept);
        Model _head = IteratorExtensions.<Model>head(Iterators.<Model>filter(resource.getAllContents(), Model.class));
        final Model m = ((Model) _head);
        String _importURI = m.getImportURI();
        int _lastIndexOf = m.getImportURI().lastIndexOf("/");
        int _plus = (_lastIndexOf + 1);
        final String filename = _importURI.substring(_plus, m.getImportURI().lastIndexOf("."));
        fsa.generateFile((((filename + "/operations/") + conceptName) + "_test.txt"), content);
      }
    }
  }
  
  public void groupRulesByConcept(final Resource resource) {
    final Function1<Rule, EClass> _function = (Rule it) -> {
      return it.getConclusion().getFrom().getConcept();
    };
    final Map<EClass, List<Rule>> rulesByConcept = IteratorExtensions.<EClass, Rule>groupBy(Iterators.<Rule>filter(resource.getAllContents(), Rule.class), _function);
    final Function1<EClass, Boolean> _function_1 = (EClass c) -> {
      boolean _isAbstract = c.isAbstract();
      return Boolean.valueOf((!_isAbstract));
    };
    final Iterable<EClass> concreteClasses = IterableExtensions.<EClass>filter(rulesByConcept.keySet(), _function_1);
    for (final EClass concept : concreteClasses) {
      {
        final List<Rule> rules = RuleUtils.getRulesFor(concept, rulesByConcept);
        final Comparator<Rule> _function_2 = (Rule r1, Rule r2) -> {
          return RuleUtils.compareRules(r1, r2);
        };
        rules.sort(_function_2);
        this.rulesForConcept.put(concept, rules);
      }
    }
  }
  
  public void createSymbolTableForRules() {
    final Set<EClass> concepts = this.rulesForConcept.keySet();
    for (final EClass concept : concepts) {
      {
        final List<Rule> rules = this.rulesForConcept.get(concept);
        for (final Rule rule : rules) {
          {
            final Map<SymbolDef, String> ruleSymbols = this.getPathForSymbols(rule.getConclusion().getFrom());
            EList<Premise> _premises = rule.getPremises();
            for (final Premise premise : _premises) {
              SingleTermDef _to = premise.getTo();
              if ((_to instanceof SymbolDef)) {
                SingleTermDef _to_1 = premise.getTo();
                String _name = premise.getFrom().getDef().getName();
                String _plus = ("computed_" + _name);
                ruleSymbols.put(((SymbolDef) _to_1), _plus);
              } else {
                SingleTermDef _to_2 = premise.getTo();
                if ((_to_2 instanceof DefConfiguration)) {
                  SingleTermDef _to_3 = premise.getTo();
                  ruleSymbols.putAll(this.getPathForSymbols(((DefConfiguration) _to_3)));
                }
              }
            }
            this.symbolTable.put(rule, ruleSymbols);
          }
        }
      }
    }
  }
  
  public String compileOperationFor(final EClass concept) {
    String out = "";
    final List<Rule> rules = this.rulesForConcept.get(concept);
    for (int i = 0; (i < rules.size());) {
      {
        final Rule first = rules.get(i);
        final ArrayList<Rule> group = new ArrayList<Rule>();
        group.add(first);
        int j = (i + 1);
        boolean end = false;
        while (((j < rules.size()) && (!end))) {
          {
            final DefConfiguration configI = first.getConclusion().getFrom();
            final DefConfiguration configJ = rules.get(j).getConclusion().getFrom();
            boolean _equals = EcoreUtil2.equals(configI, configJ);
            if (_equals) {
              group.add(rules.get(j));
            } else {
              end = true;
              j--;
            }
            j++;
          }
        }
        int _size = group.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          String _out = out;
          String _compileRule = this.compileRule(group);
          out = (_out + _compileRule);
        } else {
          String _out_1 = out;
          String _compileRule_1 = this.compileRule(first);
          out = (_out_1 + _compileRule_1);
        }
        i = j;
      }
    }
    return out;
  }
  
  public String compileRule(final Rule r) {
    String out = "";
    EList<Premise> _premises = r.getPremises();
    for (final Premise resolve : _premises) {
      StringConcatenation _builder = new StringConcatenation();
      SymbolRef _from = resolve.getFrom();
      _builder.append(_from);
      _builder.newLineIfNotEmpty();
      _builder.append("if(){");
      _builder.newLine();
      _builder.append("\t");
      _builder.append(out, "\t");
      _builder.newLineIfNotEmpty();
      _builder.append("}");
      _builder.newLine();
      out = _builder.toString();
    }
    EList<Condition> _conditions = r.getConditions();
    for (final Condition cond : _conditions) {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("if(");
      String _oclPredicate = cond.getOclPredicate();
      _builder_1.append(_oclPredicate);
      _builder_1.append("){");
      _builder_1.newLineIfNotEmpty();
      _builder_1.append("\t");
      _builder_1.append(out, "\t");
      _builder_1.newLineIfNotEmpty();
      _builder_1.append("}");
      _builder_1.newLine();
      out = _builder_1.toString();
    }
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("if(config.before_");
    String _name = r.getName();
    _builder_2.append(_name);
    _builder_2.append("() != null){");
    _builder_2.newLineIfNotEmpty();
    _builder_2.append("\t");
    _builder_2.append("config.before_");
    String _name_1 = r.getName();
    _builder_2.append(_name_1, "\t");
    _builder_2.append("().do(config);");
    _builder_2.newLineIfNotEmpty();
    _builder_2.append("}");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("if(config.specialize_");
    String _name_2 = r.getName();
    _builder_2.append(_name_2);
    _builder_2.append("() != null){");
    _builder_2.newLineIfNotEmpty();
    _builder_2.append("\t");
    _builder_2.append("config.specialize_");
    String _name_3 = r.getName();
    _builder_2.append(_name_3, "\t");
    _builder_2.append("().do(vis, node, ctx, config);");
    _builder_2.newLineIfNotEmpty();
    _builder_2.append("}");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append(out);
    _builder_2.newLineIfNotEmpty();
    _builder_2.newLine();
    _builder_2.append("if(config.after_");
    String _name_4 = r.getName();
    _builder_2.append(_name_4);
    _builder_2.append("() != null){");
    _builder_2.newLineIfNotEmpty();
    _builder_2.append("\t");
    _builder_2.append("config.after_");
    String _name_5 = r.getName();
    _builder_2.append(_name_5, "\t");
    _builder_2.append("().do(config);");
    _builder_2.newLineIfNotEmpty();
    _builder_2.append("}");
    _builder_2.newLine();
    return _builder_2.toString();
  }
  
  public String compileRule(final List<Rule> rules) {
    String out = "";
    return out;
  }
  
  public Map<SymbolDef, String> getPathForSymbols(final DefConfiguration conf) {
    final EClass concept = conf.getConcept();
    final EList<EStructuralFeature> features = concept.getEAllStructuralFeatures();
    final EList<TermDef> childs = conf.getChilds();
    final int len = childs.size();
    final HashMap<SymbolDef, String> out = new HashMap<SymbolDef, String>();
    for (int i = 0; (i < len); i++) {
      {
        final TermDef child = childs.get(i);
        String _firstUpper = StringExtensions.toFirstUpper(features.get(i).getName());
        String _plus = (".get" + _firstUpper);
        final String featureGetter = (_plus + "()");
        if ((child instanceof SymbolDef)) {
          out.put(((SymbolDef)child), (featureGetter + ";"));
        } else {
          if ((child instanceof DefConfiguration)) {
            boolean _equals = ((DefConfiguration)child).getConcept().getEPackage().equals(AdaptSemGenerator.semanticdomain);
            boolean _not = (!_equals);
            if (_not) {
              final Map<SymbolDef, String> map = this.getPathForSymbols(((DefConfiguration)child));
              Set<SymbolDef> _keySet = map.keySet();
              for (final SymbolDef symbol : _keySet) {
                {
                  final String s = map.get(symbol);
                  map.put(symbol, (featureGetter + s));
                }
              }
              out.putAll(map);
            } else {
              final Map<SymbolDef, String> map_1 = this.getPathForSymbols(((DefConfiguration)child));
              Set<SymbolDef> _keySet_1 = map_1.keySet();
              for (final SymbolDef symbol_1 : _keySet_1) {
                {
                  final String s = map_1.get(symbol_1);
                  String _name = features.get(i).getName();
                  String _plus_1 = ("computed_" + _name);
                  String _plus_2 = (_plus_1 + s);
                  map_1.put(symbol_1, _plus_2);
                }
              }
              out.putAll(map_1);
            }
          } else {
            if ((child instanceof ListDef)) {
              final SingleTermDef head = ((ListDef)child).getHead();
              final SymbolDef tail = ((ListDef)child).getTail();
              String _name = features.get(i).getName();
              String _plus_1 = (".get(" + _name);
              final String headGetter = (_plus_1 + "_index);");
              final String tailGetter = ".stream().skip(1).collect(Collectors.toCollection(BasicEList::new));";
              out.put(tail, (featureGetter + tailGetter));
              if ((head instanceof SymbolDef)) {
                out.put(((SymbolDef)head), (featureGetter + headGetter));
              } else {
                if ((head instanceof DefConfiguration)) {
                  final Map<SymbolDef, String> map_2 = this.getPathForSymbols(((DefConfiguration)head));
                  Set<SymbolDef> _keySet_2 = map_2.keySet();
                  for (final SymbolDef symbol_2 : _keySet_2) {
                    {
                      final String s = map_2.get(symbol_2);
                      map_2.put(symbol_2, ((featureGetter + headGetter) + s));
                    }
                  }
                  out.putAll(map_2);
                }
              }
            }
          }
        }
      }
    }
    return out;
  }
  
  public void doGenerateOld(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Function1<Rule, EClass> _function = (Rule it) -> {
      return it.getConclusion().getFrom().getConcept();
    };
    final Map<EClass, List<Rule>> rulesByConcept = IteratorExtensions.<EClass, Rule>groupBy(Iterators.<Rule>filter(resource.getAllContents(), Rule.class), _function);
    AdaptSemGenerator.semanticdomain = IteratorExtensions.<Model>head(Iterators.<Model>filter(resource.getAllContents(), Model.class)).getSemanticdomain();
    final Function1<EClass, Boolean> _function_1 = (EClass c) -> {
      boolean _isAbstract = c.isAbstract();
      return Boolean.valueOf((!_isAbstract));
    };
    final Iterable<EClass> concreteClasses = IterableExtensions.<EClass>filter(rulesByConcept.keySet(), _function_1);
    for (final EClass concept : concreteClasses) {
      {
        final String conceptName = concept.getName();
        final List<Rule> rules = RuleUtils.getRulesFor(concept, rulesByConcept);
        final Comparator<Rule> _function_2 = (Rule r1, Rule r2) -> {
          return RuleUtils.compareRules(r1, r2);
        };
        rules.sort(_function_2);
        final Function1<Rule, String> _function_3 = (Rule it) -> {
          return it.getName();
        };
        String content = IterableExtensions.join(ListExtensions.<Rule, String>map(rules, _function_3), ", ");
        String _content = content;
        final Function1<EStructuralFeature, String> _function_4 = (EStructuralFeature it) -> {
          return it.getName();
        };
        String _join = IterableExtensions.join(ListExtensions.<EStructuralFeature, String>map(concept.getEAllStructuralFeatures(), _function_4), "\n");
        String _plus = ("\n\n" + _join);
        String _plus_1 = (_plus + "\n\n");
        content = (_content + _plus_1);
        for (final Rule rule : rules) {
          {
            final Map<SymbolDef, String> ruleSymbols = this.getPathForSymbols(rule.getConclusion().getFrom());
            EList<Premise> _premises = rule.getPremises();
            for (final Premise premise : _premises) {
              SingleTermDef _to = premise.getTo();
              if ((_to instanceof SymbolDef)) {
                SingleTermDef _to_1 = premise.getTo();
                String _name = premise.getFrom().getDef().getName();
                String _plus_2 = ("computed_" + _name);
                ruleSymbols.put(((SymbolDef) _to_1), _plus_2);
              } else {
                SingleTermDef _to_2 = premise.getTo();
                if ((_to_2 instanceof DefConfiguration)) {
                  SingleTermDef _to_3 = premise.getTo();
                  ruleSymbols.putAll(this.getPathForSymbols(((DefConfiguration) _to_3)));
                }
              }
            }
            String _content_1 = content;
            String _name_1 = rule.getName();
            String _plus_3 = (_name_1 + " :\n");
            content = (_content_1 + _plus_3);
            Set<SymbolDef> _keySet = ruleSymbols.keySet();
            for (final SymbolDef symbol : _keySet) {
              String _content_2 = content;
              String _name_2 = symbol.getName();
              String _plus_4 = (_name_2 + " : ");
              String _get = ruleSymbols.get(symbol);
              String _plus_5 = (_plus_4 + _get);
              String _plus_6 = (_plus_5 + "\n");
              content = (_content_2 + _plus_6);
            }
            String _content_3 = content;
            content = (_content_3 + "\n\n");
          }
        }
        for (int i = 0; (i < rules.size());) {
          {
            final Rule first = rules.get(i);
            String _content_1 = content;
            String _name = first.getName();
            String _plus_2 = (_name + ", ");
            content = (_content_1 + _plus_2);
            final ArrayList<Object> group = new ArrayList<Object>();
            int j = (i + 1);
            boolean end = false;
            while (((j < rules.size()) && (!end))) {
              {
                final DefConfiguration configI = first.getConclusion().getFrom();
                final DefConfiguration configJ = rules.get(j).getConclusion().getFrom();
                boolean _equals = EcoreUtil2.equals(configI, configJ);
                if (_equals) {
                  String _content_2 = content;
                  String _name_1 = rules.get(j).getName();
                  String _plus_3 = (_name_1 + ", ");
                  content = (_content_2 + _plus_3);
                } else {
                  end = true;
                  j--;
                }
                j++;
              }
            }
            String _content_2 = content;
            content = (_content_2 + "\n");
            i = j;
          }
        }
        Model _head = IteratorExtensions.<Model>head(Iterators.<Model>filter(resource.getAllContents(), Model.class));
        final Model m = ((Model) _head);
        String _importURI = m.getImportURI();
        int _lastIndexOf = m.getImportURI().lastIndexOf("/");
        int _plus_2 = (_lastIndexOf + 1);
        final String filename = _importURI.substring(_plus_2, m.getImportURI().lastIndexOf("."));
        fsa.generateFile((((filename + "/operations/") + conceptName) + "_test.txt"), content);
      }
    }
  }
  
  public static EPackage getSemanticDomain() {
    return AdaptSemGenerator.semanticdomain;
  }
}

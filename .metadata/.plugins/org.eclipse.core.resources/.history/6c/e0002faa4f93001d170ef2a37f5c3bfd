package fr.irisa.diverse.adaptivesemantics.generator

import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.EClass

class SemanticInterfaceGenerator {
	/**************************************************
	 * 
	 * 
	 *      GENERATE ADAPTATION INTERFACES FUNCTIONS
	 * 
	 * 
	 **************************************************/
	
	
	def String compileInterfaceFor(EClass concept, List<Rule> rules){
		val supertypes = concept.ESuperTypes
		val superClass = supertypes.filter[c | ! c.interface].head
		val interfaces = supertypes.filter[c | c.interface && (superClass === null || ! superClass.EAllSuperTypes.contains(c))]
		var implementsClause = if(!supertypes.empty) interfaces.join(", ", [type | NamingUtils.interfaceNameFor(type.name)]) else "SemanticsAdaptationInterface"
		
		
		
		var out = ""
		
		for (rule : rules) {
			out = '''
			private AdaptationRule before_«rule.name»;
			private AdaptationRule specialize_«rule.name»;
			private AdaptationRule after_«rule.name»;
			«out»
			public void add_before_«rule.name»(AdaptationRule adapt){
				adapt.chain(before_«rule.name»);
				before_«rule.name» = adapt;
			}
			public void add_specialize_«rule.name»(AdaptationRule adapt){
				adapt.chain(specialize_«rule.name»);
				specialize_«rule.name» = adapt;
			}
			public void add_after_«rule.name»(AdaptationRule adapt){
				adapt.chain(after_«rule.name»);
				after_«rule.name» = adapt;
			}
			public AdaptationRule before_«rule.name»(){return before_«rule.name»;}
			public AdaptationRule specialize_«rule.name»(){return specialize_«rule.name»;}
			public AdaptationRule after_«rule.name»(){return after_«rule.name»;}
			'''
		}
		
		return '''
		package «AdaptSemGenerator.modelName».interfaces;
		
		import fr.gjouneau.savm.framework.lang.semantics.SemanticsAdaptationInterface;
		import «AdaptSemGenerator.modelName».ASOS.AdaptationRule;
		
		public class «concept.name»Interface implements «implementsClause» {
			«out»
		}
		'''
	}
	
	def String compileAbstractInterfaceFor(EClass concept, List<Rule>  rules){
		val supertypes = concept.ESuperTypes
		val interfaces = supertypes.filter[c | c.interface]
		var extendsClause = if(!supertypes.empty) interfaces.join(", ", [type | NamingUtils.interfaceNameFor(type.name)]) else "SemanticsAdaptationInterface"
		
		
		
		var out = ""
		
		for (rule : rules) {
			out = '''
			«out»
			public void add_before_«rule.name»(AdaptationRule adapt);
			public void add_specialize_«rule.name»(AdaptationRule adapt);
			public void add_after_«rule.name»(AdaptationRule adapt);
			public AdaptationRule before_«rule.name»();
			public AdaptationRule specialize_«rule.name»();
			public AdaptationRule after_«rule.name»();
			'''
		}
		
		return '''
		package «AdaptSemGenerator.modelName».interfaces;
		
		import fr.gjouneau.savm.framework.lang.semantics.SemanticsAdaptationInterface;
		import «AdaptSemGenerator.modelName».ASOS.AdaptationRule;
		
		public interface «concept.name»Interface extends «extendsClause» {
			«out»
		}
		'''
	}
	
}
/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.adaptivesemantics.generator

import fr.irisa.diverse.adaptivesemantics.generator.visitors.RuleCompiler
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef
import java.util.ArrayList
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

class AdaptSemGenerator extends AbstractGenerator {
	
	var Map<EClass, List<Rule>> conceptRules = newHashMap;
	var Map<EClass, List<Rule>> allRulesForConcept = newHashMap;
	var Map<Rule, Map<SymbolDef, String>> symbolTable = newHashMap;
	static var EPackage semanticdomain;
	static var String modelName;





	/**	
	 * Entrypoint of the generator
	 * 
	 * @param resource : result of the parser
	 * @param fsa : access to the filesystem to generate files
	 * @param context : unused
	 *	 
	 */
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val metamodel = resource.allContents.filter(Model).head as Model
		semanticdomain = metamodel.semanticdomain
		modelName = NamingUtils.nameOf(metamodel)
		
		val rules = resource.allContents.filter(Rule).toList
		conceptRules = rules.groupBy[conclusion.from.concept]
			
		//SemanticInterfaceGenerator.compileInterfaces(conceptRules, fsa)
		val interface = compileInterface(rules)
		fsa.generateFile(NamingUtils.interfacePathFor(modelName, modelName), interface)
			
		groupRulesByConcept(conceptRules)
		createSymbolTableForRules()
		
		
		val concepts = allRulesForConcept.keySet
		for (concept : concepts) {
			val conceptName = concept.name
			val operation = compileOperationFor(concept)
			fsa.generateFile(NamingUtils.operationPathFor(modelName, conceptName), operation)
		}
	}
	
	
	
	
	
	
	/**************************************************
	 * 
	 * 
	 *      SETUP FUNCTIONS
	 * 
	 * 
	 **************************************************/
	
	
	
	
	
	
	
	/**	
	 * Associate a concept to the list of rules that can be applied to it
	 * 
	 * @param rulesByConcept : map from concept (used as input in rules) to the list of rules defined for this exact concept
	 */
	def void groupRulesByConcept(Map<EClass, List<Rule>>  rulesByConcept){
		val concreteClasses = rulesByConcept.keySet.filter([EClass c | ! (c.interface || c.abstract)])
		for (concept : concreteClasses) {
			val rules = RuleUtils.getRulesFor(concept, rulesByConcept)
			rules.sort([Rule r1, Rule r2 | RuleUtils.compareRules(r1, r2)])
			allRulesForConcept.put(concept, rules)
		}
	}
	
	/**	
	 * Resolve symbols defined in rules to EMF model queries
	 */
	def void createSymbolTableForRules(){
		val concepts = allRulesForConcept.keySet
		for (concept : concepts) {
			val rules = allRulesForConcept.get(concept)
			for (rule : rules) {
				val ruleSymbols = NamingUtils.getPathForSymbols(rule.conclusion.from)
				
				for(premise : rule.premises){
					if(premise.to instanceof SymbolDef){
						ruleSymbols.put(premise.to as SymbolDef, NamingUtils.computedNameFor(premise.from))
					} else if (premise.to instanceof DefConfiguration){
						ruleSymbols.putAll(NamingUtils.getPathForSymbols(premise.to as DefConfiguration))
					}
				}
				symbolTable.put(rule, ruleSymbols)
			}
		}
	}
	
	
	
	
	
	/**************************************************
	 * 
	 * 
	 *      GENERATE RULES FUNCTIONS
	 * 
	 * 
	 **************************************************/
	
	/**
	 * Generate the operation class for SEALS from the semantic rules for a given concept
	 * 
	 * @param concept : EClass representing the concept to generate the semantic for
	 */
	def String compileOperationFor(EClass concept){
		var out = ""
		val rules = allRulesForConcept.get(concept)
		
		var computedTerms = ""
		val features = concept.EAllStructuralFeatures
		for (feature : features) {
			computedTerms = '''
			«computedTerms»
			Object «NamingUtils.computedNameFor(feature.name)» = null;
			'''
			
		}
			
		for(var i = 0; i < rules.size; i++){
			val first = rules.get(i)
			/*val group = new ArrayList
			group.add(first)
			
			var j = i + 1
			var end = false
			while(j < rules.size && !end){
				val configI = first.conclusion.from
				val configJ = rules.get(j).conclusion.from
				
				if(EcoreUtil2.equals(configI, configJ)){
					group.add(rules.get(j))
				} else {
					end = true
					j--
				}					
				j++
			}
			if(group.size > 1){
				out += compileRule(group)
			} else {
				out += compileRule(first)
			}
			
			
			i = j*/
			out += compileRule(first)
		}
		
		return '''
		package «modelName».operations;
		
		import org.eclipse.emf.ecore.EObject;
		import fr.gjouneau.savm.framework.lang.semantics.AdaptiveOperation;
		import fr.gjouneau.savm.framework.lang.semantics.Node;
		import fr.gjouneau.savm.framework.lang.semantics.Operationalize;
		import fr.gjouneau.savm.framework.lang.semantics.SelfAdaptiveVisitor;
		import «modelName».ASOS.Termination;
		import «modelName».«concept.name»;
		import «modelName».interfaces.«NamingUtils.interfaceNameFor(modelName)»;
		import «modelName».«semanticdomain.name».«semanticdomain.name»Package;
		
		@Operationalize(node = «concept.name».class, visitor = "«modelName».visitors.«modelName»Visitor")
		public class «concept.name»Op extends AdaptiveOperation<«concept.name», «NamingUtils.interfaceNameFor(modelName)»>{
			
			@Override
			public Object execute(SelfAdaptiveVisitor vis, «concept.name» node, Object execCtx, «NamingUtils.interfaceNameFor(modelName)» config) {
				«computedTerms»
				
				«out»
				
				return null;
			}
		}
		'''
	}
	
	/**
	 * Generate code corresponding to one rule
	 * 
	 * @param r : the rule to compile to java code
	 */
	def String compileRule(Rule r){
		val ruleTable = symbolTable.get(r)
		val ruleCompiler = new RuleCompiler(ruleTable)
		val out = ruleCompiler.compile(r)
		
		return '''
		if(config.before_«r.name»() != null){
			config.before_«r.name»().adapt(vis, node, execCtx, config);
		}
		
		if(config.specialize_«r.name»() != null){
			config.specialize_«r.name»().adapt(vis, node, execCtx, config);
		} else {
			«out»
		}
		
		if(config.after_«r.name»() != null){
			config.after_«r.name»().adapt(vis, node, execCtx, config);
		}
		'''
	}
	
	/**@TODO
	 * Generate code corresponding to a set of alternatives (rules) needing premises evaluation to select
	 * 
	 * @param rules : the rules seen as possible alternatives
	 */
	def String compileRule(List<Rule> rules){
		var out = ""
		
		return out
	}
	
	
	
	
	
	/**************************************************
	 * 
	 * 
	 *      GENERATE ADAPTATION INTERFACE 
	 * 
	 * 
	 **************************************************/
	
	def String compileInterface(List<Rule>  rules){
		var out = ""
		for (rule : rules) {
			out = '''
			private AdaptationRule before_«rule.name»;
			private AdaptationRule specialize_«rule.name»;
			private AdaptationRule after_«rule.name»;
			«out»
			public void add_before_«rule.name»(AdaptationRule adapt){
				adapt.chain(before_«rule.name»);
				before_«rule.name» = adapt;
			}
			public void add_specialize_«rule.name»(AdaptationRule adapt){
				adapt.chain(specialize_«rule.name»);
				specialize_«rule.name» = adapt;
			}
			public void add_after_«rule.name»(AdaptationRule adapt){
				adapt.chain(after_«rule.name»);
				after_«rule.name» = adapt;
			}
			public AdaptationRule before_«rule.name»(){return before_«rule.name»;}
			public AdaptationRule specialize_«rule.name»(){return specialize_«rule.name»;}
			public AdaptationRule after_«rule.name»(){return after_«rule.name»;}
			'''
		}
		
		return '''
		package «AdaptSemGenerator.modelName».interfaces;
		
		import fr.gjouneau.savm.framework.lang.semantics.SemanticsAdaptationInterface;
		import «AdaptSemGenerator.modelName».ASOS.AdaptationRule;
		
		public class «NamingUtils.interfaceNameFor(modelName)» implements SemanticsAdaptationInterface {
			«out»
		}
		'''
	}
	
	

	
	
	
	
	
	
	
	
	







	
	
	
	
	
	def void doGenerateOld(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val rulesByConcept = resource.allContents
			.filter(Rule)
			.groupBy[conclusion.from.concept]
			
		semanticdomain = resource.allContents.filter(Model).head.semanticdomain
			
		val concreteClasses = rulesByConcept.keySet.filter([EClass c | ! c.abstract])
		for (concept : concreteClasses) {
			val conceptName = concept.name
			val rules = RuleUtils.getRulesFor(concept, rulesByConcept)
			
			rules.sort([Rule r1, Rule r2 | RuleUtils.compareRules(r1, r2)])
			
			// Structural features are ordered as in the ecore tree viz and hierarchicaly farthest in the inheritance = first in the list
			var content = rules.map[name].join(", ")
			content += "\n\n" + concept.EAllStructuralFeatures.map[name].join("\n") + "\n\n"
			
			for (rule : rules) {
				//symbolTable.put(rule, getPathForSymbols(rule.conclusion.from))
				val ruleSymbols = NamingUtils.getPathForSymbols(rule.conclusion.from)
				
				for(premise : rule.premises){
					if(premise.to instanceof SymbolDef){
						ruleSymbols.put(premise.to as SymbolDef, "computed_" + premise.from.def.name)
					} else if (premise.to instanceof DefConfiguration){
						ruleSymbols.putAll(NamingUtils.getPathForSymbols(premise.to as DefConfiguration))
					}
				}
				
				content += rule.name + " :\n"
				for (symbol : ruleSymbols.keySet) {
					content += symbol.name + " : " + ruleSymbols.get(symbol) + "\n"
				}
				content += "\n\n"
			}
			
			for(var i = 0; i < rules.size;){
				val first = rules.get(i)
				content += first.name + ", "
				val group = new ArrayList
				//group.add(first)
				
				var j = i + 1
				var end = false
				while(j < rules.size && !end){
					val configI = first.conclusion.from
					val configJ = rules.get(j).conclusion.from
					
					if(EcoreUtil2.equals(configI, configJ)){
						content += rules.get(j).name + ", "
						//group.add(rules.get(j))
					} else {
						end = true
						j--
					}
					
					j++
				}
				content += "\n"
				//if(group.size > 1){
					//content += compileRule(group)
				//} else {
					//content += compileRule(first)
				//}
				
				
				i = j
			}
			val m = resource.allContents.filter(Model).head as Model
			val filename = m.importURI.substring(m.importURI.lastIndexOf('/')+1, m.importURI.lastIndexOf('.'))
			fsa.generateFile(filename + "/operations/" + conceptName+'_test.txt', content)
		}
				
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
	}
	
	static def EPackage getSemanticDomain(){
		return semanticdomain
	}
	
	static def String getModelName(){
		return modelName
	}
}

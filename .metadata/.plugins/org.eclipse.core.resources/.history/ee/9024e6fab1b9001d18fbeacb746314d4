package fr.irisa.diverse.adaptivesemantics.generator.visitors

import fr.irisa.diverse.adaptivesemantics.generator.AdaptSemGenerator
import fr.irisa.diverse.adaptivesemantics.generator.RuleUtils
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListDef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListRef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.RefConfiguration
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolRef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.VoidList
import fr.irisa.diverse.adaptivesemantics.generator.NamingUtils

class PatternCheckerCompiler {
	
	val condName= "validPattern"
	
	def String generateCheck(DefConfiguration pattern){
		var out = ""
		
		val concept = pattern.concept
		val features = concept.EAllStructuralFeatures
		val childs = pattern.childs
		val len = childs.size
		
		for (var i = 0; i < len; i++) {
			val child = childs.get(i)
			val featureGetter = ".get" + features.get(i).name.toFirstUpper + "()"
			
			if (child instanceof DefConfiguration){
				out = '''
				«out»
				«child.compile("((" + child.concept.name + ") " + NamingUtils.computedNameFor(features.get(i).name) + ")")»
				'''
			} else {
				out = '''
				«out»
				«child.compile("node" + featureGetter)»
				'''
			}
		}
		
		return '''
		boolean «condName» = true;
		«out»
		'''
	}
	
	def dispatch String compile(DefConfiguration node, String path){
		val concept = node.concept
		val features = concept.EAllStructuralFeatures
		val childs = node.childs
		val len = childs.size
		
		var out = '''
		«condName» = «condName» && («path» instanceof «concept.name»);
		'''		
		
		for (var i = 0; i < len; i++) {
			val child = childs.get(i)
			val featureGetter = ".get" + features.get(i).name.toFirstUpper + "()"
			
			out = '''
			«out»
			«child.compile("((" + concept.name + ") " + path + featureGetter + ")")»
			'''
		}
		
		return out
	}
	
	def dispatch String compile(VoidList node, String path){
		return '''
		«condName» = «condName» && («path» instanceof List && «path».empty());
		'''
	}
	
	def dispatch String compile(ListDef node, String path){
		return '''
		«condName» = «condName» && («path» instanceof List);
		«node.head.compile(path + ".get(0)")»
		'''
	}
	
	def dispatch String compile(SymbolDef node, String path){
		return ""
	}
	
}
/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.adaptivesemantics.generator

import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListDef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import fr.irisa.diverse.adaptivesemantics.generator.RuleUtils

class AdaptSemGenerator extends AbstractGenerator {
	
	var Map<EClass, List<Rule>> rulesForConcept = newHashMap;
	var Map<Rule, Map<SymbolDef, String>> symbolTable = newHashMap;
	static var EPackage semanticdomain;
	var String modelName;


	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		semanticdomain = resource.allContents.filter(Model).head.semanticdomain
		groupRulesByConcept(resource)
		createSymbolTableForRules()
		
		val concepts = rulesForConcept.keySet
		for (concept : concepts) {
			val conceptName = concept.name
			                compileNodeImplFor(concept)
			val operation = compileOperationFor(concept)
			val interface = compileInterfaceFor(concept)
			
			val m = resource.allContents.filter(Model).head as Model
			modelName = m.importURI.substring(m.importURI.lastIndexOf('/')+1, m.importURI.lastIndexOf('.'))
			println(fsa.readTextFile(conceptName) + "\n\n\n\n\n")
			fsa.generateFile(modelName + "/operations/" + conceptName + 'Op.java', operation)
			fsa.generateFile(modelName + "/interfaces/" + conceptName + 'Interface.java', interface)
		}
	}
	
	def void groupRulesByConcept(Resource resource){
		val rulesByConcept = resource.allContents
			.filter(Rule)
			.groupBy[conclusion.from.concept]
			
		val concreteClasses = rulesByConcept.keySet.filter([EClass c | ! c.abstract])
		for (concept : concreteClasses) {
			val rules = RuleUtils.getRulesFor(concept, rulesByConcept)
			rules.sort([Rule r1, Rule r2 | RuleUtils.compareRules(r1, r2)])
			rulesForConcept.put(concept, rules)
			
		}
	}
	
	def void createSymbolTableForRules(){
		val concepts = rulesForConcept.keySet
		for (concept : concepts) {
			val rules = rulesForConcept.get(concept)
			for (rule : rules) {
				val ruleSymbols = getPathForSymbols(rule.conclusion.from)
				
				for(premise : rule.premises){
					if(premise.to instanceof SymbolDef){
						ruleSymbols.put(premise.to as SymbolDef, "computed_" + premise.from.def.name)
					} else if (premise.to instanceof DefConfiguration){
						ruleSymbols.putAll(getPathForSymbols(premise.to as DefConfiguration))
					}
				}
				
				symbolTable.put(rule, ruleSymbols)
			}
			
		}
	}
	
	def String compileOperationFor(EClass concept){
		var out = ""
		val rules = rulesForConcept.get(concept)
			
		for(var i = 0; i < rules.size; i++){
			val first = rules.get(i)
			/*val group = new ArrayList
			group.add(first)
			
			var j = i + 1
			var end = false
			while(j < rules.size && !end){
				val configI = first.conclusion.from
				val configJ = rules.get(j).conclusion.from
				
				if(EcoreUtil2.equals(configI, configJ)){
					group.add(rules.get(j))
				} else {
					end = true
					j--
				}					
				j++
			}
			if(group.size > 1){
				out += compileRule(group)
			} else {
				out += compileRule(first)
			}
			
			
			i = j*/
			out += compileRule(first)
		}
		
		return '''
		package «modelName».operations;
		
		import fr.gjouneau.savm.framework.lang.semantics.AdaptiveOperation;
		import fr.gjouneau.savm.framework.lang.semantics.Operationalize;
		import fr.gjouneau.savm.framework.lang.semantics.SelfAdaptiveVisitor;
		import «modelName».ASOS.Termination;
		import «modelName».«concept.name»;
		import «modelName».interfaces.«concept.name»Interface;
		
		@Operationalize(node = «concept.name».class, visitor = "«modelName».visitors.«modelName»Visitor")
		public class «concept.name»Op extends AdaptiveOperation<«concept.name», «concept.name»Interface>{
			
			@Override
			public Object execute(SelfAdaptiveVisitor vis, «concept.name» node, Object execCtx, «concept.name»Interface config) {
				«out»
			}
		}
		'''
	}
	
	def String compileInterfaceFor(EClass concept){
		var out = ""
		
		val rules = rulesForConcept.get(concept)
		
		for (rule : rules) {
			out = '''
			private AdaptationRule before_«rule.name»;
			private AdaptationRule specialize_«rule.name»;
			private AdaptationRule after_«rule.name»;
			«out»
			public void add_before_«rule.name»(AdaptationRule adapt){
				adapt.chain(before_«rule.name»);
				before_«rule.name» = adapt;
			}
			public void add_specialize_«rule.name»(AdaptationRule adapt){
				adapt.chain(specialize_«rule.name»);
				specialize_«rule.name» = adapt;
			}
			public void add_after_«rule.name»(AdaptationRule adapt){
				adapt.chain(after_«rule.name»);
				after_«rule.name» = adapt;
			}
			public AdaptationRule before_«rule.name»(){return before_«rule.name»;}
			public AdaptationRule specialize_«rule.name»(){return specialize_«rule.name»;}
			public AdaptationRule after_«rule.name»(){return after_«rule.name»;}
			'''
		}
		
		return '''
		package «modelName».interfaces;
		
		import fr.gjouneau.savm.framework.lang.semantics.SemanticsAdaptationInterface;
		import «modelName».ASOS.AdaptationRule;
		
		public class «concept.name»Interface implements SemanticsAdaptationInterface {
			«out»
		}
		'''
	}
	
	def String compileNodeImplFor(EClass concept){
		return '''
		@Override
		public «concept.name»Interface defaultInterface() {
			return new «concept.name»Interface();
		}
		'''
	}
	
	def String compileRule(Rule r){
		val ruleTable = symbolTable.get(r)
		
		var out = "// PERFORM THE TRANSITION"
		
		for (binding : r.bindings) {
			out = '''
			Object «binding.assignee» = «binding.oclExpression»
			«out»
			'''
		}
		
		for (resolve : r.premises) {
			out = '''
			Object local_computed_«resolve.from.def.name» = node«ruleTable.get(resolve.from.def)».accept(vis, execCtx);
			if(«IF ! resolve.termination»!«ENDIF»(local_computed_«resolve.from.def.name» instanceof Termination)){
				«out»
			}
			'''
		}
		
		for (cond : r.conditions) {
			out = '''
			if(«cond.oclPredicate»){
				«out»
			}
			'''
		}
		
		for (in : r.inputs) {
			out = '''
			Object «in.assignee» = «in.operation.name»
			«out»
			'''
		}
		
		for (output : r.outputs) {
			out = '''
			«out»
			«output.operation.name» ();
			'''
		}
		
		return '''
		if(config.before_«r.name»() != null){
			config.before_«r.name»().adapt(vis, node, execCtx, config);
		}
		
		if(config.specialize_«r.name»() != null){
			config.specialize_«r.name»().adapt(vis, node, execCtx, config);
		} else {
			«out»
		}
		
		if(config.after_«r.name»() != null){
			config.after_«r.name»().adapt(vis, node, execCtx, config);
		}
		'''
	}
	
	def String compileRule(List<Rule> rules){
		var out = ""
		
		return out
	}
	
	def Map<SymbolDef, String> getPathForSymbols(DefConfiguration conf){
		val concept = conf.concept
		val features = concept.EAllStructuralFeatures
		val childs = conf.childs
		val len = childs.size
		
		val out = new HashMap
		
		for (var i = 0; i < len; i++) {
			val child = childs.get(i)
			val featureGetter = ".get" + features.get(i).name.toFirstUpper + "()"
			
			if(child instanceof SymbolDef){
				out.put(child, featureGetter)
			} else if (child instanceof DefConfiguration){
				if(! child.concept.EPackage.equals(semanticdomain)){
					val map = getPathForSymbols(child)
					for (symbol : map.keySet) {
						val s = map.get(symbol)
						map.put(symbol, featureGetter + s)	
					}
					out.putAll(map)
				} else {
					val map = getPathForSymbols(child)
					for (symbol : map.keySet) {
						val s = map.get(symbol)
						map.put(symbol, "computed_" + features.get(i).name + s)	
					}
					out.putAll(map)
				}
			} else if (child instanceof ListDef){
				val head = child.head
				val tail = child.tail
				
				val headGetter = ".get(" + features.get(i).name + "_index)"
				val tailGetter = ".stream().skip(1).collect(Collectors.toCollection(BasicEList::new))"
				
				out.put(tail, featureGetter + tailGetter)
				
				if(head instanceof SymbolDef){
					out.put(head, featureGetter + headGetter)
				} else if (head instanceof DefConfiguration){
					val map = getPathForSymbols(head)
					for (symbol : map.keySet) {
						val s = map.get(symbol)
						map.put(symbol, featureGetter + headGetter + s)	
					}
					out.putAll(map)
				}
			}
		}
		
		
		return out
	}
	
	
	def void doGenerateOld(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val rulesByConcept = resource.allContents
			.filter(Rule)
			.groupBy[conclusion.from.concept]
			
		semanticdomain = resource.allContents.filter(Model).head.semanticdomain
			
		val concreteClasses = rulesByConcept.keySet.filter([EClass c | ! c.abstract])
		for (concept : concreteClasses) {
			val conceptName = concept.name
			val rules = RuleUtils.getRulesFor(concept, rulesByConcept)
			
			rules.sort([Rule r1, Rule r2 | RuleUtils.compareRules(r1, r2)])
			
			// Structural features are ordered as in the ecore tree viz and hierarchicaly farthest in the inheritance = first in the list
			var content = rules.map[name].join(", ")
			content += "\n\n" + concept.EAllStructuralFeatures.map[name].join("\n") + "\n\n"
			
			for (rule : rules) {
				//symbolTable.put(rule, getPathForSymbols(rule.conclusion.from))
				val ruleSymbols = getPathForSymbols(rule.conclusion.from)
				
				for(premise : rule.premises){
					if(premise.to instanceof SymbolDef){
						ruleSymbols.put(premise.to as SymbolDef, "computed_" + premise.from.def.name)
					} else if (premise.to instanceof DefConfiguration){
						ruleSymbols.putAll(getPathForSymbols(premise.to as DefConfiguration))
					}
				}
				
				content += rule.name + " :\n"
				for (symbol : ruleSymbols.keySet) {
					content += symbol.name + " : " + ruleSymbols.get(symbol) + "\n"
				}
				content += "\n\n"
			}
			
			for(var i = 0; i < rules.size;){
				val first = rules.get(i)
				content += first.name + ", "
				val group = new ArrayList
				//group.add(first)
				
				var j = i + 1
				var end = false
				while(j < rules.size && !end){
					val configI = first.conclusion.from
					val configJ = rules.get(j).conclusion.from
					
					if(EcoreUtil2.equals(configI, configJ)){
						content += rules.get(j).name + ", "
						//group.add(rules.get(j))
					} else {
						end = true
						j--
					}
					
					j++
				}
				content += "\n"
				//if(group.size > 1){
					//content += compileRule(group)
				//} else {
					//content += compileRule(first)
				//}
				
				
				i = j
			}
			val m = resource.allContents.filter(Model).head as Model
			val filename = m.importURI.substring(m.importURI.lastIndexOf('/')+1, m.importURI.lastIndexOf('.'))
			fsa.generateFile(filename + "/operations/" + conceptName+'_test.txt', content)
		}
				
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
	}
	
	static def EPackage getSemanticDomain(){
		return semanticdomain
	}
}

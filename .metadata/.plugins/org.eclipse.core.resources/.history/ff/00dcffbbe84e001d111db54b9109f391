/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.semanticadaptation.serializer;

import com.google.inject.Inject;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.AdaptiveSemantics;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.AdaptivesemanticsPackage;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Conclusion;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Condition;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Import;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListRef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.NameBinding;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Premise;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.RefConfiguration;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SemanticDomainAccess;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SemanticDomainUpdate;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolRef;
import fr.irisa.diverse.adaptivesemantics.serializer.AdaptSemSemanticSequencer;
import fr.irisa.diverse.semanticadaptation.services.SemAdaptGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import semanticadaptation.After;
import semanticadaptation.Before;
import semanticadaptation.Pointcut;
import semanticadaptation.SemanticAdaptation;
import semanticadaptation.SemanticadaptationPackage;
import semanticadaptation.Semantics;
import semanticadaptation.Specialization;

@SuppressWarnings("all")
public class SemAdaptSemanticSequencer extends AdaptSemSemanticSequencer {

	@Inject
	private SemAdaptGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AdaptivesemanticsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AdaptivesemanticsPackage.ADAPTIVE_SEMANTICS:
				sequence_AdaptiveSemantics(context, (AdaptiveSemantics) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.CONCLUSION:
				sequence_Conclusion(context, (Conclusion) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.DEF_CONFIGURATION:
				sequence_DefConfiguration(context, (DefConfiguration) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.LIST_DEF:
				sequence_ListDef(context, (ListDef) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.LIST_REF:
				sequence_ListRef(context, (ListRef) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.NAME_BINDING:
				sequence_NameBinding(context, (NameBinding) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.PREMISE:
				sequence_Premise(context, (Premise) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.REF_CONFIGURATION:
				sequence_RefConfiguration(context, (RefConfiguration) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SEMANTIC_DOMAIN_ACCESS:
				sequence_SemanticDomainAccess(context, (SemanticDomainAccess) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SEMANTIC_DOMAIN_UPDATE:
				sequence_SemanticDomainUpdate(context, (SemanticDomainUpdate) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SYMBOL_DEF:
				sequence_SymbolDef(context, (SymbolDef) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SYMBOL_REF:
				sequence_SymbolRef(context, (SymbolRef) semanticObject); 
				return; 
			}
		else if (epackage == SemanticadaptationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SemanticadaptationPackage.AFTER:
				sequence_Adaptation(context, (After) semanticObject); 
				return; 
			case SemanticadaptationPackage.BEFORE:
				sequence_Adaptation(context, (Before) semanticObject); 
				return; 
			case SemanticadaptationPackage.MODULE:
				sequence_Module(context, (semanticadaptation.Module) semanticObject); 
				return; 
			case SemanticadaptationPackage.POINTCUT:
				sequence_Pointcut(context, (Pointcut) semanticObject); 
				return; 
			case SemanticadaptationPackage.SEMANTIC_ADAPTATION:
				sequence_SemanticAdaptation(context, (SemanticAdaptation) semanticObject); 
				return; 
			case SemanticadaptationPackage.SEMANTICS:
				sequence_Semantics(context, (Semantics) semanticObject); 
				return; 
			case SemanticadaptationPackage.SPECIALIZATION:
				sequence_Adaptation(context, (Specialization) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Adaptation returns After
	 *
	 * Constraint:
	 *     (target=[Rule|ID] adaptation=Rule)
	 */
	protected void sequence_Adaptation(ISerializationContext context, After semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__TARGET));
			if (transientValues.isValueTransient(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__ADAPTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__ADAPTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdaptationAccess().getTargetRuleIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SemanticadaptationPackage.Literals.ADAPTATION__TARGET, false));
		feeder.accept(grammarAccess.getAdaptationAccess().getAdaptationRuleParserRuleCall_2_0(), semanticObject.getAdaptation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Adaptation returns Before
	 *
	 * Constraint:
	 *     (target=[Rule|ID] adaptation=Rule)
	 */
	protected void sequence_Adaptation(ISerializationContext context, Before semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__TARGET));
			if (transientValues.isValueTransient(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__ADAPTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__ADAPTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdaptationAccess().getTargetRuleIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SemanticadaptationPackage.Literals.ADAPTATION__TARGET, false));
		feeder.accept(grammarAccess.getAdaptationAccess().getAdaptationRuleParserRuleCall_2_0(), semanticObject.getAdaptation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Adaptation returns Specialization
	 *
	 * Constraint:
	 *     (target=[Rule|ID] adaptation=Rule)
	 */
	protected void sequence_Adaptation(ISerializationContext context, Specialization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__TARGET));
			if (transientValues.isValueTransient(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__ADAPTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SemanticadaptationPackage.Literals.ADAPTATION__ADAPTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdaptationAccess().getTargetRuleIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SemanticadaptationPackage.Literals.ADAPTATION__TARGET, false));
		feeder.accept(grammarAccess.getAdaptationAccess().getAdaptationRuleParserRuleCall_2_0(), semanticObject.getAdaptation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (name=ID pointcuts+=Pointcut* adaptations+=Adaptation*)
	 */
	protected void sequence_Module(ISerializationContext context, semanticadaptation.Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pointcut returns Pointcut
	 *
	 * Constraint:
	 *     (recursive?='recursive'? structure=DefConfiguration (conditions+=Condition conditions+=Condition*)?)
	 */
	protected void sequence_Pointcut(ISerializationContext context, Pointcut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SemanticAdaptation returns SemanticAdaptation
	 *
	 * Constraint:
	 *     (model=Model semantics=Semantics imports+=Import* modules+=Module*)
	 */
	protected void sequence_SemanticAdaptation(ISerializationContext context, SemanticAdaptation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Semantics returns Semantics
	 *
	 * Constraint:
	 *     importURI=EString
	 */
	protected void sequence_Semantics(ISerializationContext context, Semantics semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SemanticadaptationPackage.Literals.SEMANTICS__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SemanticadaptationPackage.Literals.SEMANTICS__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSemanticsAccess().getImportURIEStringParserRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
}

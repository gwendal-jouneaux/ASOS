/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.semanticadaptation.generator

import fr.irisa.diverse.adaptivesemantics.generator.NamingUtils
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SemAdaptGenerator extends AbstractGenerator {

	static var EPackage semanticdomain;
	static var String modelName;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val metamodel = resource.allContents.filter(Model).head as Model
		semanticdomain = metamodel.semanticdomain
		modelName = NamingUtils.nameOf(metamodel)
//		
//		val rules = resource.allContents.filter(Rule).toList
//		conceptRules = rules.groupBy[conclusion.from.concept]
//			
//		//SemanticInterfaceGenerator.compileInterfaces(conceptRules, fsa)
//		val interface = compileInterface(rules)
//		fsa.generateFile(NamingUtils.interfacePathFor(modelName, modelName), interface)
//			
//		groupRulesByConcept(conceptRules)
//		createSymbolTableForRules()
//		
//		
//		val concepts = allRulesForConcept.keySet
//		for (concept : concepts) {
//			val conceptName = concept.name
//			val operation = compileOperationFor(concept)
//			fsa.generateFile(NamingUtils.operationPathFor(modelName, conceptName), operation)
//		}
	}
	
	def String compileModule(Module module){
		val matches = ""
		val rules = ""
		return '''
		package «modelName».adaptations;
		
		import «modelName».interfaces.«NamingUtils.interfaceNameFor(modelName)»;
		
		public class «module.name» extends SelfAdaptationModule<«modelName»AdaptationContext, AdaptableNode<«NamingUtils.interfaceNameFor(modelName)»>, «NamingUtils.interfaceNameFor(modelName)»> {

			
			public «module.name»() {
				super("«module.name»", AdaptableNode.class);
			}
		
			@Override
			public ForInterface adapt(ForInterface configInterface) {
				«rules»
			}
		
			@Override
			public boolean isTargetedNode(AdaptableNode<ForInterface> adaptableNode) {
				«matches»
			}
		}
		'''
	}
}

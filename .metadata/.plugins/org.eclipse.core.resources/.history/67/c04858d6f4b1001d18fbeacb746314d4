package fr.irisa.diverse.adaptivesemantics.generator.visitors

import fr.irisa.diverse.adaptivesemantics.generator.NamingUtils
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.And
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Binding
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.BoolConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Conclusion
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Condition
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Div
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DoubleConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Equal
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Expr
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Input
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.IntConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Less
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.LessEq
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Minus
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Mult
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Not
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.NotEqual
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Or
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Output
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Plus
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Premise
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.RefConfiguration
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SemanticDomainAccess
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.StringConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolRef
import java.util.Map

class RuleCompiler {
	
	val Map<SymbolDef, String> ruleTable
	
	new(Map<SymbolDef, String> table){
		ruleTable = table
	}
	
	def dispatch String compile(Rule node){
		var out = node.conclusion.compile
		
		for (binding : node.bindings) {
			binding.compile
		}
		
		for (resolve : node.premises) {
			resolve.compile
		}
		
		for (cond : node.conditions) {
			cond.compile
		}
		
		for (in : node.inputs) {
			in.compile
		}
		
		for (output : node.outputs) {
			output.compile
		}
		
		return out
	}
	
	def dispatch String compile(Premise node){
		return '''
		Object local_computed_«node.from.def.name» = node«ruleTable.get(node.from.def)».accept(vis, execCtx);
		if(«IF ! node.termination»!«ENDIF»(local_computed_«node.from.def.name» instanceof Termination)){
			
		}
		'''
	}
	
	def dispatch String compile(Conclusion node){
		
	}
	
	def dispatch String compile(Condition node){
		return '''
		if(«(node.cond as Expr).compile»){
			
		}
		'''
	}
	
	def dispatch String compile(Binding node){
		val assignee = node.assignee
		val assignable  = node.expr
		val toAssign = switch (assignable){
			SemanticDomainAccess:
				NamingUtils.pathFor(assignable, ruleTable)
			RefConfiguration:
				"null"
			Expr:
				assignable.compile
		}
		if(assignee instanceof SymbolDef){
			return '''
			Object «assignee.name» = «toAssign»;
			'''
		}
		if(assignee instanceof SemanticDomainAccess){
			return '''
			«NamingUtils.pathFor(assignee.reciever, ruleTable)».set«assignee.field.toFirstUpper»(«toAssign»);
			'''
		}
	}
	
	def dispatch String compile(Input node){
		return '''
		Object «node.assignee» = «node.operation.name»
		'''
	}
	
	def dispatch String compile(Output node){
		return '''
		«node.operation.name»();
		'''
	}
	
	def dispatch String compile(Plus node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" + "+rhs+")"
	}
	
	def dispatch String compile(Minus node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" - "+rhs+")"
	}
	
	def dispatch String compile(Div node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" / "+rhs+")"
	}
	
	def dispatch String compile(Mult node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" * "+rhs+")"
	}
	
	def dispatch String compile(Or node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" || "+rhs+")"
	}
	
	def dispatch String compile(And node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" && "+rhs+")"
	}
	
	def dispatch String compile(Not node) {
		val expr = node.expr.compile
		return "(!"+expr+")"
	}
	
	def dispatch String compile(Less node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" < "+rhs+")"
	}
	
	def dispatch String compile(LessEq node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" <= "+rhs+")"
	}
	
	def dispatch String compile(Equal node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+".equals("+rhs+"))"
	}
	
	def dispatch String compile(NotEqual node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "(!"+lhs+".equals("+rhs+"))"
	}
	
	def dispatch String compile(IntConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(BoolConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(StringConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(DoubleConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(SymbolRef node) {
		val access = ruleTable.getOrDefault(node.def, node.def.name)
		return (access.startsWith(".") ? "node" : "") + access
	}
}
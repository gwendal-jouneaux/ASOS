package fr.irisa.diverse.adaptivesemantics.generator.visitors

import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.And
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Binding
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.BoolConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Conclusion
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Condition
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Div
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DoubleConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Equal
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Input
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.IntConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Less
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.LessEq
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Minus
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Mult
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Not
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.NotEqual
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Or
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Output
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Plus
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Premise
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.StringConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolRef
import java.util.Map

class RuleCompiler {
	
	val Map<SymbolDef, String> ruleTable
	
	new(Map<SymbolDef, String> table){
		ruleTable = table
	}
	
	def dispatch String compile(Rule node){
		
	}
	
	def dispatch String compile(Premise node){
		
	}
	
	def dispatch String compile(Conclusion node){
		
	}
	
	def dispatch String compile(Condition node){
		
	}
	
	def dispatch String compile(Binding node){
		
	}
	
	def dispatch String compile(Input node){
		
	}
	
	def dispatch String compile(Output node){
		
	}
	
	def dispatch String compile(Plus node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" + "+rhs+")"
	}
	
	def dispatch String compile(Minus node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" - "+rhs+")"
	}
	
	def dispatch String compile(Div node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" / "+rhs+")"
	}
	
	def dispatch String compile(Mult node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" * "+rhs+")"
	}
	
	def dispatch String compile(Or node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" || "+rhs+")"
	}
	
	def dispatch String compile(And node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" && "+rhs+")"
	}
	
	def dispatch String compile(Not node) {
		val expr = node.expr.compile
		return "(!"+expr+")"
	}
	
	def dispatch String compile(Less node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" < "+rhs+")"
	}
	
	def dispatch String compile(LessEq node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" <= "+rhs+")"
	}
	
	def dispatch String compile(Equal node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+".equals("+rhs+"))"
	}
	
	def dispatch String compile(NotEqual node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "(!"+lhs+".equals("+rhs+"))"
	}
	
	def dispatch String compile(IntConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(BoolConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(StringConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(DoubleConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(SymbolRef node) {
		val access = ruleTable.getOrDefault(node.def, node.def.name)
		return (access.startsWith(".") ? "node" : "") + access
	}
}
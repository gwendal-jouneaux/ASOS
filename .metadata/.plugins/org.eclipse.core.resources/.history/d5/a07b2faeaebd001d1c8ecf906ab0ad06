/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.semanticadaptation.generator

import fr.irisa.diverse.adaptivesemantics.generator.NamingUtils
import fr.irisa.diverse.adaptivesemantics.generator.visitors.RuleCompiler
import fr.irisa.diverse.adaptivesemantics.generator.visitors.SymbolPath
import fr.irisa.diverse.adaptivesemantics.generator.visitors.SymbolResolver
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import semanticadaptation.Adaptation
import semanticadaptation.After
import semanticadaptation.Before
import semanticadaptation.Specialization
import semanticadaptation.Module

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SemAdaptGenerator extends AbstractGenerator {
	
	static var String modelName;

	var Map<Rule, Map<SymbolDef, SymbolPath>> symbolTable = newHashMap;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val metamodel = resource.allContents.filter(Model).head as Model
		//semanticdomain = metamodel.semanticdomain
		modelName = NamingUtils.nameOf(metamodel)
		
		val adaptations = resource.allContents.filter(Adaptation).toList
		val adaptationRules = adaptations.map[adaptation | adaptation.adaptation]
		createSymbolTableForRules(adaptationRules)
		
		
		val modules = resource.allContents.filter(Module).toList
		for (module : modules) {
			val moduleName = module.name
			val moduleCode = compileModule(module)
			fsa.generateFile(NamingUtils.modulePathFor(modelName, moduleName), moduleCode)
		}
		
		
		
//			
//		//SemanticInterfaceGenerator.compileInterfaces(conceptRules, fsa)
//		val interface = compileInterface(rules)
//		fsa.generateFile(NamingUtils.interfacePathFor(modelName, modelName), interface)
//			
//		groupRulesByConcept(conceptRules)
//		createSymbolTableForRules()
//		
//		
//		val concepts = allRulesForConcept.keySet
//		for (concept : concepts) {
//			val conceptName = concept.name
//			val operation = compileOperationFor(concept)
//			fsa.generateFile(NamingUtils.operationPathFor(modelName, conceptName), operation)
//		}
	}
	
	/**	
	 * Resolve symbols defined in rules to EMF model queries
	 */
	def void createSymbolTableForRules(List<Rule> rules){
		for (rule : rules) {
			val resolver = new SymbolResolver()
			
			resolver.resolveFor(rule)
			val ruleSymbols = resolver.symbolTable
			
			symbolTable.put(rule, ruleSymbols)
		}
	}
	
	def String compileModule(Module module){
		val matches = ""
		val addrules = ""
		
		for (adaptation : module.adaptations) {
			
		}
		
		
		return '''
		package «modelName».adaptations.modules;
		
		import «modelName».interfaces.«NamingUtils.interfaceNameFor(modelName)»;
		
		public class «module.name» extends SelfAdaptationModule<«modelName»AdaptationContext, AdaptableNode<«NamingUtils.interfaceNameFor(modelName)»>, «NamingUtils.interfaceNameFor(modelName)»> {

			
			public «module.name»() {
				super("«module.name»", AdaptableNode.class);
			}
		
			@Override
			public «NamingUtils.interfaceNameFor(modelName)» adapt(«NamingUtils.interfaceNameFor(modelName)» configInterface) {
				«addrules»
			}
		
			@Override
			public boolean isTargetedNode(AdaptableNode<«NamingUtils.interfaceNameFor(modelName)»> adaptableNode) {
				«matches»
			}
		}
		'''
	}
	
	def dispatch String compileAdaptation(Specialization adaptation){
		val adaptationRuleName = adaptation.adaptation.name
		val adaptedRuleName = adaptation.target.name
		return '''configInterface.add_specialize_«adaptedRuleName»(new «adaptationRuleName»())'''
	}
	
	def dispatch String compileAdaptation(Before adaptation){
		val adaptationRuleName = adaptation.adaptation.name
		val adaptedRuleName = adaptation.target.name
		return '''configInterface.add_before_«adaptedRuleName»(new «adaptationRuleName»())'''
	}
	
	def dispatch String compileAdaptation(After adaptation){
		val adaptationRuleName = adaptation.adaptation.name
		val adaptedRuleName = adaptation.target.name
		return '''configInterface.add_after_«adaptedRuleName»(new «adaptationRuleName»())'''
	}
	
	def String compileAdaptationRule(Rule rule){
		val ruleTable = symbolTable.get(rule)
		val ruleCompiler = new RuleCompiler(ruleTable)
		val compiledRule = ruleCompiler.compile(rule)
		return '''
		package «modelName».adaptations.modules;
		
		public class «rule.name» extend AdaptationRule {
			@Override
			public Object adapt(SelfAdaptiveVisitor vis, AdaptableNode<? extends SemanticsAdaptationInterface> node, Object execCtx, SemanticsAdaptationInterface config){
				Object result = null;
				
				«compiledRule»
				
				return result
			}
		}
		'''
	}
}

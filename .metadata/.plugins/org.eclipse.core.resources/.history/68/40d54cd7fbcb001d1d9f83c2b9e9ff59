/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.semanticadaptation.generator

import fr.irisa.diverse.adaptivesemantics.generator.NamingUtils
import fr.irisa.diverse.adaptivesemantics.generator.visitors.PatternCheckerCompiler
import fr.irisa.diverse.adaptivesemantics.generator.visitors.RuleCompiler
import fr.irisa.diverse.adaptivesemantics.generator.visitors.SymbolPath
import fr.irisa.diverse.adaptivesemantics.generator.visitors.SymbolResolver
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import semanticadaptation.Adaptation
import semanticadaptation.After
import semanticadaptation.Before
import semanticadaptation.Module
import semanticadaptation.Pointcut
import semanticadaptation.Specialization

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SemAdaptGenerator extends AbstractGenerator {
	
	static var String modelName;

	var Map<Rule, Map<SymbolDef, SymbolPath>> symbolTable = newHashMap;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val metamodel = resource.allContents.filter(Model).head as Model
		//semanticdomain = metamodel.semanticdomain
		modelName = NamingUtils.nameOf(metamodel)
		
		val adaptations = resource.allContents.filter(Adaptation).toList
		val adaptationRules = adaptations.map[adaptation | adaptation.adaptation]
		createSymbolTableForRules(adaptationRules)
		
		
		val modules = resource.allContents.filter(Module).toList
		for (module : modules) {
			val moduleName = module.name
			val moduleCode = compileModule(module, fsa)
			fsa.generateFile(NamingUtils.modulePathFor(modelName, moduleName), moduleCode)
		}
		
		
		
//			
//		//SemanticInterfaceGenerator.compileInterfaces(conceptRules, fsa)
//		val interface = compileInterface(rules)
//		fsa.generateFile(NamingUtils.interfacePathFor(modelName, modelName), interface)
//			
//		groupRulesByConcept(conceptRules)
//		createSymbolTableForRules()
//		
//		
//		val concepts = allRulesForConcept.keySet
//		for (concept : concepts) {
//			val conceptName = concept.name
//			val operation = compileOperationFor(concept)
//			fsa.generateFile(NamingUtils.operationPathFor(modelName, conceptName), operation)
//		}
	}
	
	/**	
	 * Resolve symbols defined in rules to EMF model queries
	 */
	def void createSymbolTableForRules(List<Rule> rules){
		for (rule : rules) {
			val resolver = new SymbolResolver()
			
			resolver.resolveFor(rule)
			val ruleSymbols = resolver.symbolTable
			
			symbolTable.put(rule, ruleSymbols)
		}
	}
	
	def String compileModule(Module module, IFileSystemAccess2 fsa){
		var matches = ""
		var addRules = ""
		
		for (adaptation : module.adaptations) {
			val adaptationCode = compileAdaptationRule(adaptation.adaptation)
			fsa.generateFile(NamingUtils.adaptationPathFor(modelName, NamingUtils.adaptationNameFor(adaptation.adaptation.name)), adaptationCode)
			
			addRules = '''
			«addRules»
			«adaptation.compileAdaptation»
			'''
		}
		
		for (pointcut : module.pointcuts) {
			matches = '''
			«matches»
			«compilePointcut(pointcut)»
			'''
		}
		
		return '''
		package «modelName».adaptations.modules;
		
		import «modelName».interfaces.«NamingUtils.interfaceNameFor(modelName)»;
		
		public class «NamingUtils.moduleNameFor(module.name)» extends SelfAdaptationModule<«modelName»AdaptationContext, AdaptableNode<«NamingUtils.interfaceNameFor(modelName)»>, «NamingUtils.interfaceNameFor(modelName)»> {

			
			public «NamingUtils.moduleNameFor(module.name)»() {
				super("«module.name»", AdaptableNode.class);
			}
		
			@Override
			public «NamingUtils.interfaceNameFor(modelName)» adapt(«NamingUtils.interfaceNameFor(modelName)» configInterface) {
				«addRules»
			}
		
			@Override
			public boolean isTargetedNode(AdaptableNode<«NamingUtils.interfaceNameFor(modelName)»> adaptableNode) {
				«matches»
			}
		}
		'''
	}
	
	def dispatch String compileAdaptation(Specialization adaptation){
		val adaptationRuleName = NamingUtils.adaptationNameFor(adaptation.adaptation.name)
		val adaptedRuleName = adaptation.target.name
		return '''configInterface.add_specialize_«adaptedRuleName»(new «adaptationRuleName»())'''
	}
	
	def dispatch String compileAdaptation(Before adaptation){
		val adaptationRuleName = NamingUtils.adaptationNameFor(adaptation.adaptation.name)
		val adaptedRuleName = adaptation.target.name
		return '''configInterface.add_before_«adaptedRuleName»(new «adaptationRuleName»())'''
	}
	
	def dispatch String compileAdaptation(After adaptation){
		val adaptationRuleName = NamingUtils.adaptationNameFor(adaptation.adaptation.name)
		val adaptedRuleName = adaptation.target.name
		return '''configInterface.add_after_«adaptedRuleName»(new «adaptationRuleName»())'''
	}
	
	def String compileAdaptationRule(Rule rule){
		val ruleTable = symbolTable.get(rule)
		val ruleCompiler = new RuleCompiler(ruleTable)
		val compiledRule = ruleCompiler.compile(rule)
		return '''
		package «modelName».adaptations.modules;
		
		public class «NamingUtils.adaptationNameFor(rule.name)» extend AdaptationRule {
			@Override
			public Object adapt(SelfAdaptiveVisitor vis, AdaptableNode<? extends SemanticsAdaptationInterface> node, Object execCtx, SemanticsAdaptationInterface config){
				Object result = null;
				
				«compiledRule»
				
				return result
			}
		}
		'''
	}
	
	
	def String compilePointcut(Pointcut pointcut){
		var out = ""
		if(pointcut.recursive){
			
		} else {
			
		}
		
//		val conditionCompiler = new RuleCompiler()
//		for (cond : pointcut.conditions.reverse) {
//			out = '''
//			«cond.compile»{
//				«out»
//			}
//			'''
//		}
		
		val patternCompiler = new PatternCheckerCompiler()
		out = '''
		«patternCompiler.generateInputCheck(pointcut.structure)»{
			«out»
		}
		'''
		
		return out
	}
}

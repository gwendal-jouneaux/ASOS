package fr.irisa.diverse.adaptivesemantics.generator.visitors

import fr.irisa.diverse.adaptivesemantics.generator.NamingUtils
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListDef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Premise
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.VoidList
import java.util.Map
import org.eclipse.emf.ecore.EStructuralFeature

class SymbolResolver {
	
	val Map<EStructuralFeature, SymbolPath> featureAccessors = newHashMap;
	val Map<SymbolDef, EStructuralFeature> symbolFeature = newHashMap;
	
	def void resolveFor(Rule node){
		
		
		val concept = node.conclusion.from.concept
		val features = concept.EAllStructuralFeatures
		val childs = node.conclusion.from.childs
		val len = childs.size
		
		for (var i = 0; i < len; i++) {
			val child = childs.get(i)
			val featureGetter = "node.get" + features.get(i).name.toFirstUpper + "()"
			var computedVar = NamingUtils.computedNameFor(features.get(i).name)
			val conditionalAccess = "(" + computedVar + " == null ? " + featureGetter + " : " + computedVar + ")"
			
			if (child instanceof DefConfiguration){
				val type = child.concept.name
				val castedComputedVar = '''((«type») «computedVar»)'''
			}
			
			val map = child.resolve(features.get(i))
			for (symbol : map.keySet) {
				val s = map.get(symbol)
				val newSymbolPath = new SymbolPath(featureGetter + s.termForm, computedVar + s.valueForm, conditionalAccess + s.unknownForm)
				featureAccessors.put(symbol, newSymbolPath)	
			}
		}
				
		for(premise : node.premises){
			premise.propagate()
		}
	}
		
	def dispatch Map<EStructuralFeature, SymbolPath> resolve(DefConfiguration node, EStructuralFeature feature){
		val concept = node.concept
		val features = concept.EAllStructuralFeatures
		val childs = node.childs
		val len = childs.size
		
		val out = newHashMap
		
		for (var i = 0; i < len; i++) {
			val child = childs.get(i)
			val featureGetter = ".get" + features.get(i).name.toFirstUpper + "()"
			
			val map = child.resolve(features.get(i))
			for (symbol : map.keySet) {
				val s = map.get(symbol)
				val newSymbolPath = new SymbolPath(featureGetter + s.termForm, featureGetter + s.valueForm, featureGetter + s.unknownForm)
				out.put(symbol, newSymbolPath)	
			}
		}
		
		return out
	}
	
	def dispatch Map<EStructuralFeature, SymbolPath> resolve(VoidList node, EStructuralFeature feature){
		return newHashMap
	}
	
	def dispatch Map<EStructuralFeature, SymbolPath> resolve(ListDef node, EStructuralFeature feature){
		val out = newHashMap
		out.put(feature, new SymbolPath("// TODO head", "// TODO tail", ""))
		return out
	}
	
	def dispatch Map<EStructuralFeature, SymbolPath> resolve(SymbolDef node, EStructuralFeature feature){
		val out = newHashMap
		out.put(feature, new SymbolPath("", "", ""))
		symbolFeature.put(node, feature)
		return out
	}
	
	
	
	def void propagate(Premise node){
		val feature = symbolFeature.get(node.from)
		node.to.propagate(feature)
	}
	
	def dispatch void propagate(DefConfiguration node, EStructuralFeature feature){
		val concept = node.concept
		val features = concept.EAllStructuralFeatures
		val childs = node.childs
		val len = childs.size
		
		for (var i = 0; i < len; i++) {
			val child = childs.get(i)
			child.resolve(features.get(i))
		}
		
	}
	
	def dispatch void propagate(SymbolDef node, EStructuralFeature feature){
		symbolFeature.put(node, feature)
	}
	
	
	
	def Map<SymbolDef, SymbolPath> getSymbolTable(){ 
		val out = newHashMap
		
		for (symbol : symbolFeature.keySet) {
			val feature = symbolFeature.get(symbol)
			val paths = featureAccessors.get(feature)
			out.put(symbol, paths)
		}
		
		return out
	}
	
	def Map<SymbolDef, SymbolPath> computeSymbolTable(){ 
		val out = newHashMap
		
		for (symbol : symbolFeature.keySet) {
			val feature = symbolFeature.get(symbol)
			val paths = featureAccessors.get(feature)
			out.put(symbol, paths)
		}
		
		return out
	}
}
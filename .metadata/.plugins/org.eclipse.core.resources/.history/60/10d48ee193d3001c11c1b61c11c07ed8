// automatically generated by Xtext
grammar fr.irisa.diverse.semanticadaptation.SemAdapt with org.eclipse.xtext.common.Terminals

import "http://www.diverse-team.fr/semanticadaptation" 
import "http://www.diverse-team.fr/adaptivesemantics" as adaptivesemantics
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

SemanticAdaptation returns SemanticAdaptation:
	model=Model
	semantics=Semantics
	imports+=Import*
	modules+=Modules*;


Model returns adaptivesemantics::Model:
	'model' importURI=EString;
	
Semantics returns Semantics:
	'semantics' importURI=EString;

Import returns adaptivesemantics::Import:
	'import' importURI=EString "as" name=ID;
	
Module returns Module:
	(recursive?='recursive')? name=ID
	"{"
		(pointcuts+=Pointcut)*
	"}"	
;






Adaptation returns Adaptation:
	Specialization | Before | After;


TermDef returns adaptivesemantics::TermDef:
	SymbolDef | DefConfiguration | ListDef;












ConclusionOutput returns adaptivesemantics::ConclusionOutput:
	RefConfiguration | SymbolRef | SemanticDomainUpdate | SemanticDomainAccess | ListRef | ListAppend;

TermRef returns adaptivesemantics::TermRef:
	RefConfiguration | SymbolRef | ListRef | ListAppend;



Module returns Module:
	{Module}
	(recursive?='recursive')?
	'Module'
	name=EString
	'{'
		('poincut' '{' poincut+=Poincut ( "," poincut+=Poincut)* '}' )?
		('adaptations' '{' adaptations+=Adaptation ( "," adaptations+=Adaptation)* '}' )?
	'}';


EString returns ecore::EString:
	STRING | ID;

Pointcut returns Pointcut:
	'Poincut'
	'{'
		'structure' structure=DefConfiguration
		('conditions' '{' conditions+=Condition ( "," conditions+=Condition)* '}' )?
	'}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

DefConfiguration returns adaptivesemantics::DefConfiguration:
	'DefConfiguration'
	'{'
		'concept' concept=[ecore::EClassifier|EString]
		('childs' '{' childs+=TermDef ( "," childs+=TermDef)* '}' )?
	'}';

Condition returns adaptivesemantics::Condition:
	'Condition'
	'{'
		'oclPredicate' oclPredicate=EString
	'}';

EAnnotation returns ecore::EAnnotation:
	{ecore::EAnnotation}
	'EAnnotation'
	'{'
		('source' source=EString)?
		('references' '(' references+=[ecore::EObject|EString] ( "," references+=[ecore::EObject|EString])* ')' )?
		('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('details' '{' details+=EStringToStringMapEntry ( "," details+=EStringToStringMapEntry)* '}' )?
		('contents' '{' contents+=EObject ( "," contents+=EObject)* '}' )?
	'}';

ETypeParameter returns ecore::ETypeParameter:
	{ecore::ETypeParameter}
	'ETypeParameter'
	name=EString
	'{'
		('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eBounds' '{' eBounds+=EGenericType ( "," eBounds+=EGenericType)* '}' )?
	'}';

EClass returns ecore::EClass:
	{ecore::EClass}
	(abstract?='abstract')?
	(interface?='interface')?
	'EClass'
	name=EString
	'{'
		('instanceClassName' instanceClassName=EString)?
		('instanceTypeName' instanceTypeName=EString)?
		('eSuperTypes' '(' eSuperTypes+=[ecore::EClass|EString] ( "," eSuperTypes+=[ecore::EClass|EString])* ')' )?
		('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
		('eOperations' '{' eOperations+=EOperation ( "," eOperations+=EOperation)* '}' )?
		('eStructuralFeatures' '{' eStructuralFeatures+=EStructuralFeature ( "," eStructuralFeatures+=EStructuralFeature)* '}' )?
		('eGenericSuperTypes' '{' eGenericSuperTypes+=EGenericType ( "," eGenericSuperTypes+=EGenericType)* '}' )?
	'}';

EDataType_Impl returns ecore::EDataType:
	{ecore::EDataType}
	'EDataType'
	name=EString
	'{'
		('instanceClassName' instanceClassName=EString)?
		('instanceTypeName' instanceTypeName=EString)?
		('serializable' serializable=EBoolean)?
		('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
	'}';

EEnum returns ecore::EEnum:
	{ecore::EEnum}
	'EEnum'
	name=EString
	'{'
		('instanceClassName' instanceClassName=EString)?
		('instanceTypeName' instanceTypeName=EString)?
		('serializable' serializable=EBoolean)?
		('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
		('eLiterals' '{' eLiterals+=EEnumLiteral ( "," eLiterals+=EEnumLiteral)* '}' )?
	'}';

EStringToStringMapEntry returns ecore::EStringToStringMapEntry:
	{ecore::EStringToStringMapEntry}
	'EStringToStringMapEntry'
	'{'
		('key' key=EString)?
		('value' value=EString)?
	'}';

EObject returns ecore::EObject:
	{ecore::EObject}
	'EObject'
	;

EGenericType returns ecore::EGenericType:
	{ecore::EGenericType}
	'EGenericType'
	'{'
		('eTypeParameter' eTypeParameter=[ecore::ETypeParameter|EString])?
		('eClassifier' eClassifier=[ecore::EClassifier|EString])?
		('eUpperBound' eUpperBound=EGenericType)?
		('eTypeArguments' '{' eTypeArguments+=EGenericType ( "," eTypeArguments+=EGenericType)* '}' )?
		('eLowerBound' eLowerBound=EGenericType)?
	'}';

EOperation returns ecore::EOperation:
	{ecore::EOperation}
	'EOperation'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('eType' eType=[ecore::EClassifier|EString])?
		('eExceptions' '(' eExceptions+=[ecore::EClassifier|EString] ( "," eExceptions+=[ecore::EClassifier|EString])* ')' )?
		('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
		('eParameters' '{' eParameters+=EParameter ( "," eParameters+=EParameter)* '}' )?
		('eGenericExceptions' '{' eGenericExceptions+=EGenericType ( "," eGenericExceptions+=EGenericType)* '}' )?
	'}';

EInt returns ecore::EInt:
	'-'? INT;

EParameter returns ecore::EParameter:
	{ecore::EParameter}
	'EParameter'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('eType' eType=[ecore::EClassifier|EString])?
		('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
	'}';

EAttribute returns ecore::EAttribute:
	{ecore::EAttribute}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(iD?='iD')?
	'EAttribute'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('changeable' changeable=EBoolean)?
		('defaultValueLiteral' defaultValueLiteral=EString)?
		('eType' eType=[ecore::EClassifier|EString])?
		('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
	'}';

EReference returns ecore::EReference:
	{ecore::EReference}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(containment?='containment')?
	'EReference'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('changeable' changeable=EBoolean)?
		('defaultValueLiteral' defaultValueLiteral=EString)?
		('resolveProxies' resolveProxies=EBoolean)?
		('eType' eType=[ecore::EClassifier|EString])?
		('eOpposite' eOpposite=[ecore::EReference|EString])?
		('eKeys' '(' eKeys+=[ecore::EAttribute|EString] ( "," eKeys+=[ecore::EAttribute|EString])* ')' )?
		('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
	'}';

EEnumLiteral returns ecore::EEnumLiteral:
	{ecore::EEnumLiteral}
	'EEnumLiteral'
	name=EString
	'{'
		('value' value=EInt)?
		('literal' literal=EString)?
		('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
	'}';

SymbolDef returns adaptivesemantics::SymbolDef:
	{adaptivesemantics::SymbolDef}
	'SymbolDef'
	name=EString;

ListDef returns adaptivesemantics::ListDef:
	'ListDef'
	'{'
		'head' head=SymbolDef
		'tail' tail=SymbolDef
	'}';

Rule returns adaptivesemantics::Rule:
	'Rule'
	name=EString
	'{'
		'conclusion' conclusion=Conclusion
		('premises' '{' premises+=Premise ( "," premises+=Premise)* '}' )?
		('conditions' '{' conditions+=Condition ( "," conditions+=Condition)* '}' )?
	'}';

Specialization returns Specialization:
	'Specialization'
	name=EString
	'{'
		'target' target=[adaptivesemantics::Rule|EString]
		'adaptation' adaptation=Rule
	'}';

Before returns Before:
	'Before'
	name=EString
	'{'
		'target' target=[adaptivesemantics::Rule|EString]
		'adaptation' adaptation=Rule
	'}';

After returns After:
	'After'
	name=EString
	'{'
		'target' target=[adaptivesemantics::Rule|EString]
		'adaptation' adaptation=Rule
	'}';

Conclusion returns adaptivesemantics::Conclusion:
	'Conclusion'
	'{'
		'from' from=DefConfiguration
		'to' to=ConclusionOutput
	'}';

Premise returns adaptivesemantics::Premise:
	'Premise'
	'{'
		'from' from=TermRef
		'to' to=TermDef
	'}';

RefConfiguration returns adaptivesemantics::RefConfiguration:
	'RefConfiguration'
	'{'
		'concept' concept=[ecore::EClassifier|EString]
		('childs' '{' childs+=TermRef ( "," childs+=TermRef)* '}' )?
	'}';

SymbolRef returns adaptivesemantics::SymbolRef:
	'SymbolRef'
	'{'
		'def' def=[adaptivesemantics::SymbolDef|EString]
	'}';

SemanticDomainUpdate returns adaptivesemantics::SemanticDomainUpdate:
	'SemanticDomainUpdate'
	'{'
		'path' path=[ecore::EStructuralFeature|EString]
		'value' value=TermRef
	'}';

SemanticDomainAccess returns adaptivesemantics::SemanticDomainAccess:
	'SemanticDomainAccess'
	'{'
		'path' path=[ecore::EStructuralFeature|EString]
	'}';

ListRef returns adaptivesemantics::ListRef:
	'ListRef'
	'{'
		'head' head=SymbolRef
		'tail' tail=SymbolRef
	'}';

ListAppend returns adaptivesemantics::ListAppend:
	'ListAppend'
	'{'
		'head' head=TermRef
		'tail' tail=TermRef
	'}';

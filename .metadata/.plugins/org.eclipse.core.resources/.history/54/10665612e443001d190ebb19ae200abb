/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.adaptivesemantics.serializer;

import com.google.inject.Inject;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.AdaptiveSemantics;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.AdaptivesemanticsPackage;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Conclusion;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Condition;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Import;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListAppend;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListRef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Premise;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.RefConfiguration;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SemanticDomainAccess;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SemanticDomainUpdate;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolRef;
import fr.irisa.diverse.adaptivesemantics.services.AdaptSemGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AdaptSemSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AdaptSemGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AdaptivesemanticsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AdaptivesemanticsPackage.ADAPTIVE_SEMANTICS:
				sequence_AdaptiveSemantics(context, (AdaptiveSemantics) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.CONCLUSION:
				sequence_Conclusion(context, (Conclusion) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.DEF_CONFIGURATION:
				sequence_DefConfiguration(context, (DefConfiguration) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.LIST_APPEND:
				sequence_ListAppend(context, (ListAppend) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.LIST_DEF:
				sequence_ListDef(context, (ListDef) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.LIST_REF:
				sequence_ListRef(context, (ListRef) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.PREMISE:
				sequence_Premise(context, (Premise) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.REF_CONFIGURATION:
				sequence_RefConfiguration(context, (RefConfiguration) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SEMANTIC_DOMAIN_ACCESS:
				sequence_SemanticDomainAccess(context, (SemanticDomainAccess) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SEMANTIC_DOMAIN_UPDATE:
				sequence_SemanticDomainUpdate(context, (SemanticDomainUpdate) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SYMBOL_DEF:
				sequence_SymbolDef(context, (SymbolDef) semanticObject); 
				return; 
			case AdaptivesemanticsPackage.SYMBOL_REF:
				sequence_SymbolRef(context, (SymbolRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdaptiveSemantics returns AdaptiveSemantics
	 *
	 * Constraint:
	 *     (model=Model imports+=Import* rules+=Rule*)
	 */
	protected void sequence_AdaptiveSemantics(ISerializationContext context, AdaptiveSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Conclusion returns Conclusion
	 *
	 * Constraint:
	 *     (from=DefConfiguration to=ConclusionOutput)
	 */
	protected void sequence_Conclusion(ISerializationContext context, Conclusion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.CONCLUSION__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.CONCLUSION__FROM));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.CONCLUSION__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.CONCLUSION__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConclusionAccess().getFromDefConfigurationParserRuleCall_0_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getConclusionAccess().getToConclusionOutputParserRuleCall_2_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     oclPredicate=EString
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.CONDITION__OCL_PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.CONDITION__OCL_PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getOclPredicateEStringParserRuleCall_1_0(), semanticObject.getOclPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DefConfiguration returns DefConfiguration
	 *     TermDef returns DefConfiguration
	 *
	 * Constraint:
	 *     (concept=[EClassifier|FQN] (childs+=TermDef childs+=TermDef*)?)
	 */
	protected void sequence_DefConfiguration(ISerializationContext context, DefConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (importURI=EString name=ID)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.IMPORT__IMPORT_URI));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURIEStringParserRuleCall_1_0(), semanticObject.getImportURI());
		feeder.accept(grammarAccess.getImportAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConclusionOutput returns ListAppend
	 *     TermRef returns ListAppend
	 *     ListAppend returns ListAppend
	 *
	 * Constraint:
	 *     (elements+=TermRef elements+=TermRef*)
	 */
	protected void sequence_ListAppend(ISerializationContext context, ListAppend semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermDef returns ListDef
	 *     ListDef returns ListDef
	 *
	 * Constraint:
	 *     (head=SymbolDef tail=SymbolDef)
	 */
	protected void sequence_ListDef(ISerializationContext context, ListDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.LIST_DEF__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.LIST_DEF__HEAD));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.LIST_DEF__TAIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.LIST_DEF__TAIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListDefAccess().getHeadSymbolDefParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getListDefAccess().getTailSymbolDefParserRuleCall_3_0(), semanticObject.getTail());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConclusionOutput returns ListRef
	 *     TermRef returns ListRef
	 *     ListRef returns ListRef
	 *
	 * Constraint:
	 *     (head=SymbolRef tail=SymbolRef)
	 */
	protected void sequence_ListRef(ISerializationContext context, ListRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.LIST_REF__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.LIST_REF__HEAD));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.LIST_REF__TAIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.LIST_REF__TAIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListRefAccess().getHeadSymbolRefParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getListRefAccess().getTailSymbolRefParserRuleCall_3_0(), semanticObject.getTail());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     importURI=EString
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.MODEL__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.MODEL__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getImportURIEStringParserRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Premise returns Premise
	 *
	 * Constraint:
	 *     (from=TermRef to=TermDef)
	 */
	protected void sequence_Premise(ISerializationContext context, Premise semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.PREMISE__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.PREMISE__FROM));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.PREMISE__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.PREMISE__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPremiseAccess().getFromTermRefParserRuleCall_0_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getPremiseAccess().getToTermDefParserRuleCall_2_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConclusionOutput returns RefConfiguration
	 *     RefConfiguration returns RefConfiguration
	 *     TermRef returns RefConfiguration
	 *
	 * Constraint:
	 *     (concept=[EClassifier|FQN] (childs+=TermRef childs+=TermRef*)?)
	 */
	protected void sequence_RefConfiguration(ISerializationContext context, RefConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (name=ID conclusion=Conclusion ((premises+=Premise | conditions+=Condition) premises+=Premise? (conditions+=Condition? premises+=Premise?)*)?)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConclusionOutput returns SemanticDomainAccess
	 *     SemanticDomainAccess returns SemanticDomainAccess
	 *
	 * Constraint:
	 *     path=[EStructuralFeature|AttributeFQN]
	 */
	protected void sequence_SemanticDomainAccess(ISerializationContext context, SemanticDomainAccess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.SEMANTIC_DOMAIN_ACCESS__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.SEMANTIC_DOMAIN_ACCESS__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSemanticDomainAccessAccess().getPathEStructuralFeatureAttributeFQNParserRuleCall_0_1(), semanticObject.eGet(AdaptivesemanticsPackage.Literals.SEMANTIC_DOMAIN_ACCESS__PATH, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConclusionOutput returns SemanticDomainUpdate
	 *     SemanticDomainUpdate returns SemanticDomainUpdate
	 *
	 * Constraint:
	 *     (path=[EStructuralFeature|AttributeFQN] value=TermRef)
	 */
	protected void sequence_SemanticDomainUpdate(ISerializationContext context, SemanticDomainUpdate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.SEMANTIC_DOMAIN_UPDATE__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.SEMANTIC_DOMAIN_UPDATE__PATH));
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.SEMANTIC_DOMAIN_UPDATE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.SEMANTIC_DOMAIN_UPDATE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSemanticDomainUpdateAccess().getPathEStructuralFeatureAttributeFQNParserRuleCall_0_0_1(), semanticObject.eGet(AdaptivesemanticsPackage.Literals.SEMANTIC_DOMAIN_UPDATE__PATH, false));
		feeder.accept(grammarAccess.getSemanticDomainUpdateAccess().getValueTermRefParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SymbolDef returns SymbolDef
	 *     TermDef returns SymbolDef
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SymbolDef(ISerializationContext context, SymbolDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.SYMBOL_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.SYMBOL_DEF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConclusionOutput returns SymbolRef
	 *     SymbolRef returns SymbolRef
	 *     TermRef returns SymbolRef
	 *
	 * Constraint:
	 *     def=[SymbolDef|ID]
	 */
	protected void sequence_SymbolRef(ISerializationContext context, SymbolRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdaptivesemanticsPackage.Literals.SYMBOL_REF__DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdaptivesemanticsPackage.Literals.SYMBOL_REF__DEF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolRefAccess().getDefSymbolDefIDTerminalRuleCall_1_0_1(), semanticObject.eGet(AdaptivesemanticsPackage.Literals.SYMBOL_REF__DEF, false));
		feeder.finish();
	}
	
	
}

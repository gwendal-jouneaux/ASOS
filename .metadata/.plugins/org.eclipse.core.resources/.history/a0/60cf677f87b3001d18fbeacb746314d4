package fr.irisa.diverse.adaptivesemantics.generator.visitors

import fr.irisa.diverse.adaptivesemantics.generator.AdaptSemGenerator
import fr.irisa.diverse.adaptivesemantics.generator.NamingUtils
import fr.irisa.diverse.adaptivesemantics.generator.RuleUtils
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.And
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Binding
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.BoolConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Conclusion
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Condition
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Div
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DoubleConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Equal
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Expr
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Input
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.IntConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Less
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.LessEq
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Minus
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Mult
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Not
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.NotEqual
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Or
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Output
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Plus
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Premise
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.RefConfiguration
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Self
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SemanticDomainAccess
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.StringConstant
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolRef
import java.util.Map

class RuleCompiler {
	
	val Map<SymbolDef, String> ruleTable
	
	new(Map<SymbolDef, String> table){
		ruleTable = table
	}
	
	def dispatch String compile(Rule node){
		var out = ""
		
		for (binding : node.bindings) {
			out = '''
			«out»
			«binding.compile»
			'''
		}
		
		out = '''
		«out»
		$CONCLUSION$
		'''
		
		for (resolve : node.premises.reverse) {
			out = '''
			«resolve.compile»
				{
					«out»
				}
			}
			'''
		}
		
		for (cond : node.conditions.reverse) {
			out = '''
			«cond.compile»{
				«out»
			}
			'''
		}
		
		for (input : node.inputs) {
			out = '''
			«input.compile»
			«out»
			'''
		}
		
		for (output : node.outputs) {
			out = '''
			«out»
			«output.compile»
			'''
		}
		
		return out.replace("$CONCLUSION$", node.conclusion.compile)
	}
	
	def dispatch String compile(Premise node){
		return '''
		if(«NamingUtils.computedNameFor(node.from)» != null){
			Object local_computed_«node.from.def.name» = ((Node) «ruleTable.get(node.from.def)»).accept(vis, execCtx);
			if(«IF ! node.termination»!«ENDIF»(local_computed_«node.from.def.name» instanceof Termination))
		'''
	}
	
	def dispatch String compile(Conclusion node){
		if(node.to instanceof RefConfiguration){
			val conf = node.to as RefConfiguration
			if(RuleUtils.isValue(conf.concept)){
				return '''
				«RuleUtils.generateInstanceOf(conf, "out", ruleTable)»
				return out;
				'''
			} else if (conf.concept.equals(node.from.concept)){
				val features = conf.concept.EAllStructuralFeatures
				val childs = conf.childs
				val len = childs.size
				
				val cp = new ConfigurationComparator(ruleTable)
				
				return '''
				// TODO «cp.compare(node.from, conf)»
				'''
			} else (
				return '''
				«RuleUtils.generateInstanceOf(conf, "out", ruleTable)»
				return ((Node)out).accept(vis, execCtx);
				'''
			)
		}
		if(node.to instanceof SymbolRef){
			val symbol = node.to as SymbolRef
			return '''
			Object out = «ruleTable.getOrDefault(symbol.def, symbol.def.name)»;
			if(! ((EObject) out).eClass().getEPackage().equals(«AdaptSemGenerator.semanticDomain.name»Package.eINSTANCE)){
				return ((Node)out).accept(vis, execCtx);
			}
			return out;
			'''
		}
	}
	
	def dispatch String compile(Condition node){
		return '''
		if(«(node.cond as Expr).compile»)
		'''
	}
	
	def dispatch String compile(Binding node){
		val assignee = node.assignee
		val assignable  = node.expr
		val toAssign = switch (assignable){
			SemanticDomainAccess:
				NamingUtils.pathFor(assignable, ruleTable)
			RefConfiguration:
				"null"
			Expr:
				assignable.compile
		}
		if(assignee instanceof SymbolDef){
			return '''
			Object «assignee.name» = «toAssign»;
			'''
		}
		if(assignee instanceof SemanticDomainAccess){
			return '''
			«NamingUtils.pathFor(assignee.reciever, ruleTable)».set«assignee.field.toFirstUpper»(«toAssign»);
			'''
		}
	}
	
	def dispatch String compile(Input node){
		return '''
		Object «node.assignee» = «node.operation.name»
		'''
	}
	
	def dispatch String compile(Output node){
		return '''
		«node.operation.name»();
		'''
	}
	
	def dispatch String compile(Plus node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" + "+rhs+")"
	}
	
	def dispatch String compile(Minus node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" - "+rhs+")"
	}
	
	def dispatch String compile(Div node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" / "+rhs+")"
	}
	
	def dispatch String compile(Mult node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" * "+rhs+")"
	}
	
	def dispatch String compile(Or node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" || "+rhs+")"
	}
	
	def dispatch String compile(And node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" && "+rhs+")"
	}
	
	def dispatch String compile(Not node) {
		val expr = node.expr.compile
		return "(!"+expr+")"
	}
	
	def dispatch String compile(Less node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" < "+rhs+")"
	}
	
	def dispatch String compile(LessEq node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+" <= "+rhs+")"
	}
	
	def dispatch String compile(Equal node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "("+lhs+".equals("+rhs+"))"
	}
	
	def dispatch String compile(NotEqual node) {
		val lhs = node.lhs.compile
		val rhs = node.rhs.compile
		return "(!"+lhs+".equals("+rhs+"))"
	}
	
	def dispatch String compile(IntConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(BoolConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(StringConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(DoubleConstant node) {
		return node.value.toString
	}
	
	def dispatch String compile(Self node) {
		return "node"
	}
	
	def dispatch String compile(SymbolRef node) {
		return ruleTable.getOrDefault(node.def, node.def.name)
	}
}
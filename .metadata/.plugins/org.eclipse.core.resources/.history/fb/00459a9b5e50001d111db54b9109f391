/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.adaptivesemantics.validation;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.validation.Check;

import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.AdaptivesemanticsPackage;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Conclusion;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.RefConfiguration;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.TermDef;
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.TermRef;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class AdaptSemValidator extends AbstractAdaptSemValidator {
	
	public static final String INVALID_SUB_TERM = "invalidSubTerm";

	@Check
	public void validConclusionPatternmatching(Conclusion conclusion) {
		DefConfiguration conf = conclusion.getFrom();
		Model m = (Model) conclusion.eContainer().eContainer().eGet(AdaptivesemanticsPackage.Literals.ADAPTIVE_SEMANTICS__MODEL);
		EPackage semanticDomain = m.getSemanticdomain();
			
		validRuleDefConfiguration(conf, semanticDomain);
	}
	
	private void validRuleDefConfiguration(DefConfiguration conf, EPackage semanticDomain) {
		for(TermDef term : conf.getChilds()) {
			if(term instanceof DefConfiguration) {
				EClass concept = ((DefConfiguration) term).getConcept();
				if(! concept.getEPackage().equals(semanticDomain)) {
					error("Rules pattern can not inspect child structure",
							AdaptivesemanticsPackage.Literals.CONCLUSION__FROM,
							INVALID_SUB_TERM);
				} else {
					validRuleDefConfiguration((DefConfiguration) term, semanticDomain);
				}
			}
		}
	}
	
	
	@Check
	public void validPremisePatternmatching(Conclusion conclusion) {
		DefConfiguration conf = conclusion.getFrom();
		Model m = (Model) conclusion.eContainer().eContainer().eGet(AdaptivesemanticsPackage.Literals.ADAPTIVE_SEMANTICS__MODEL);
		EPackage semanticDomain = m.getSemanticdomain();
			
		validRuleDefConfiguration(conf, semanticDomain);
	}
	
	private void validRuleInput(RefConfiguration conf, EPackage semanticDomain) {
		for(TermRef term : conf.getChilds()) {
			if(term instanceof RefConfiguration) {
				EClass concept = ((RefConfiguration) term).getConcept();
				if(! concept.getEPackage().equals(semanticDomain)) {
					error("Rules pattern can not inspect child structure",
							AdaptivesemanticsPackage.Literals.CONCLUSION__FROM,
							INVALID_SUB_TERM);
				} else {
					validRuleInput((RefConfiguration) term, semanticDomain);
				}
			}
		}
	}
	
}

/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.diverse.adaptivesemantics.generator

import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.DefConfiguration
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.ListDef
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Model
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.Rule
import fr.irisa.diverse.adaptivesemantics.model.adaptivesemantics.SymbolDef
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

class AdaptSemGenerator extends AbstractGenerator {
	
	var  Map<EClass, List<Rule>> rulesByConcept;
	var  Map<Rule, Map<SymbolDef, String>> symbolTable;
	var EPackage semanticdomain;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		rulesByConcept = resource.allContents
			.filter(Rule)
			.groupBy[conclusion.from.concept]
			
		semanticdomain = resource.allContents.filter(Model).head.semanticdomain
			
		val concreteClasses = rulesByConcept.keySet.filter([EClass c | ! c.abstract])
		for (concept : concreteClasses) {
			val conceptName = concept.name
			val rules = getRulesFor(concept)
			
			rules.sort([Rule r1, Rule r2 | compareRules(r1, r2)])
			
			// Structural features are ordered as in the ecore tree viz and hierarchicaly farthest in the inheritance = first in the list
			var content = rules.map[name].join(", ")
			content += "\n\n" + concept.EAllStructuralFeatures.map[name].join("\n") + "\n\n"
			
			for (rule : rules) {
				//symbolTable.put(rule, getPathForSymbols(rule.conclusion.from))
				val ruleSymbols = getPathForSymbols(rule.conclusion.from)
				content += rule.name + " :\n"
				for (symbol : ruleSymbols.keySet) {
					content += symbol.name + " : " + ruleSymbols.get(symbol) + "\n"
				}
				content += "\n\n"
			}
			
			for(var i = 0; i < rules.size;){
				val first = rules.get(i)
				content += first.name + ", "
				val group = new ArrayList
				//group.add(first)
				
				var j = i + 1
				var end = false
				while(j < rules.size && !end){
					val configI = first.conclusion.from
					val configJ = rules.get(j).conclusion.from
					
					if(EcoreUtil2.equals(configI, configJ)){
						content += rules.get(j).name + ", "
						//group.add(rules.get(j))
					} else {
						end = true
						j--
					}
					
					j++
				}
				content += "\n"
				//if(group.size > 1){
					//content += compileRule(group)
				//} else {
					//content += compileRule(first)
				//}
				
				
				i = j
			}
			
			fsa.generateFile(conceptName+'_test.txt', content)
		}
				
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
	}
	
	def List<Rule> getRulesFor(EClass clazz){
			var out = rulesByConcept.getOrDefault(clazz, new ArrayList<Rule>())
			
			val superTypes = clazz.ESuperTypes
			
			for(sup : superTypes){
				out.addAll(getRulesFor(sup))
			}
			
			return out
	}
	
	def String compileRule(Rule r){
		
		var out = ""
		
		for (resolve : r.premises) {
			out = '''
			«resolve.from»
			if(){
				«out»
			}
			'''
		}
		
		for (cond : r.conditions) {
			out = '''
			if(«cond.oclPredicate»){
				«out»
			}
			'''
		}
		
		return '''
		if(config.before_«r.name»() != null){
			config.before_«r.name»().do(config);
		}
		
		if(config.specialize_«r.name»() != null){
			config.specialize_«r.name»().do(vis, node, ctx, config);
		}
		
		
		
		if(config.after_«r.name»() != null){
			config.after_«r.name»().do(config);
		}
		'''
	}
	
	def String compileRule(List<Rule> rules){
		
		var out = ""
		
		
		
		return out
	}
	
	/*
	def boolean isLooping(ConclusionOutput to, EClassifier concept){
		if(!(to instanceof RefConfiguration)){
			return false
		}
		val config = to as RefConfiguration
		for (child : config.childs) {
			isLoopingRec(child, concept)
		}
		return true
	}
	
	def boolean isLoopingRec(TermRef to, EClassifier concept){		
		if(to instanceof RefConfiguration){
			if(to.concept == concept){
				return true
			} else {
				for (child : to.childs) {
					if(isLoopingRec(child, concept)) return true
				}
			}
		}
		return false
	}*/
	
	def Map<SymbolDef, String> getPathForSymbols(DefConfiguration conf){
		val concept = conf.concept
		val features = concept.EAllStructuralFeatures
		val childs = conf.childs
		val len = childs.size
		
		val out = new HashMap
		
		for (var i = 0; i < len; i++) {
			val child = childs.get(i)
			val featureGetter = ".get" + features.get(i).name.toFirstUpper + "()"
			
			if(child instanceof SymbolDef){
				out.put(child, featureGetter + ";")
			} else if (child instanceof DefConfiguration){
				if(! child.concept.EPackage.equals(semanticdomain)){
					val map = getPathForSymbols(child)
					for (symbol : map.keySet) {
						val s = map.get(symbol)
						map.put(symbol, featureGetter + s)	
					}
					out.putAll(map)
				} else {
					val map = getPathForSymbols(child)
					for (symbol : map.keySet) {
						val s = map.get(symbol)
						map.put(symbol, "computed_" + features.get(i).name + s)	
					}
					out.putAll(map)
				}
			} else if (child instanceof ListDef){
				val head = child.head
				val tail = child.tail
				
				val headGetter = ".get(headindex);"
				val tailGetter = ".stream().skip(1).collect(Collectors.toCollection(BasicEList::new));"
				
				out.put(tail, featureGetter + tailGetter)
				
				if(head instanceof SymbolDef){
					out.put(head, featureGetter + headGetter)
				} else if (head instanceof DefConfiguration){
					val map = getPathForSymbols(head)
					for (symbol : map.keySet) {
						val s = map.get(symbol)
						map.put(symbol, featureGetter + headGetter + s)	
					}
					out.putAll(map)
				}
			}
		}
		
		
		return out
	}
	
	def int compareRules(Rule r1, Rule r2){
		for(var index = 0; index < r1.conclusion.from.childs.length; index++){
			val child1 = r1.conclusion.from.childs.get(index)
			val child2 = r2.conclusion.from.childs.get(index)
			if(child1 instanceof DefConfiguration){
				if(!(child2 instanceof DefConfiguration)){
					return 1
				}
			} else {
				if(child2 instanceof DefConfiguration){
					return -1
				}
			}
		}
		return 0
	}
}
